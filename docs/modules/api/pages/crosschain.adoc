:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:ERC7786Receiver: pass:normal[xref:crosschain.adoc#ERC7786Receiver[`ERC7786Receiver`]]
:ERC7786OpenBridge: pass:normal[xref:crosschain.adoc#ERC7786OpenBridge[`ERC7786OpenBridge`]]
:IERC7786Receiver: pass:normal[xref:interfaces.adoc#IERC7786Receiver[`IERC7786Receiver`]]
:IERC7786Receiver: pass:normal[xref:interfaces.adoc#IERC7786Receiver[`IERC7786Receiver`]]
= Crosschain

[.readme-notice]
NOTE: This document is better viewed at https://docs.openzeppelin.com/community-contracts/api/crosschain

Gateways are contracts that enable cross-chain communication. These can either be a message source or a destination according to ERC-7786.

 * {ERC7786Receiver}: ERC-7786 cross-chain message receiver.
 * {ERC7786OpenBridge}: ERC-7786 "N out of M" gateway. Sends a message through M gateways and executes on the destination if N received it.

Developers can access interoperability protocols through gateway adapters. The library includes the following gateway adapters:

 * {AxelarGatewayBase}: Core gateway logic for the https://www.axelar.network/[Axelar] adapter.
 * {AxelarGatewaySource}: ERC-7786 source gateway adapter (sending side) for Axelar.
 * {AxelarGatewayDestination}: ERC-7786 destination gateway adapter (receiving side) for Axelar.
 * {AxelarGatewayDuplex}: ERC-7786 gateway adapter that operates in both directions (i.e. send and receive messages) using the Axelar network.

== Gateways

:Outbox: pass:normal[xref:#ERC7786OpenBridge-Outbox[`++Outbox++`]]
:Tracker: pass:normal[xref:#ERC7786OpenBridge-Tracker[`++Tracker++`]]
:OutboxDetails: pass:normal[xref:#ERC7786OpenBridge-OutboxDetails-bytes32-struct-ERC7786OpenBridge-Outbox---[`++OutboxDetails++`]]
:Received: pass:normal[xref:#ERC7786OpenBridge-Received-bytes32-address-[`++Received++`]]
:ExecutionSuccess: pass:normal[xref:#ERC7786OpenBridge-ExecutionSuccess-bytes32-[`++ExecutionSuccess++`]]
:ExecutionFailed: pass:normal[xref:#ERC7786OpenBridge-ExecutionFailed-bytes32-[`++ExecutionFailed++`]]
:GatewayAdded: pass:normal[xref:#ERC7786OpenBridge-GatewayAdded-address-[`++GatewayAdded++`]]
:GatewayRemoved: pass:normal[xref:#ERC7786OpenBridge-GatewayRemoved-address-[`++GatewayRemoved++`]]
:ThresholdUpdated: pass:normal[xref:#ERC7786OpenBridge-ThresholdUpdated-uint8-[`++ThresholdUpdated++`]]
:UnsupportedNativeTransfer: pass:normal[xref:#ERC7786OpenBridge-UnsupportedNativeTransfer--[`++UnsupportedNativeTransfer++`]]
:ERC7786OpenBridgeInvalidCrosschainSender: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeInvalidCrosschainSender--[`++ERC7786OpenBridgeInvalidCrosschainSender++`]]
:ERC7786OpenBridgeAlreadyExecuted: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeAlreadyExecuted--[`++ERC7786OpenBridgeAlreadyExecuted++`]]
:ERC7786OpenBridgeRemoteNotRegistered: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeRemoteNotRegistered-bytes2-bytes-[`++ERC7786OpenBridgeRemoteNotRegistered++`]]
:ERC7786OpenBridgeGatewayAlreadyRegistered: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeGatewayAlreadyRegistered-address-[`++ERC7786OpenBridgeGatewayAlreadyRegistered++`]]
:ERC7786OpenBridgeGatewayNotRegistered: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeGatewayNotRegistered-address-[`++ERC7786OpenBridgeGatewayNotRegistered++`]]
:ERC7786OpenBridgeThresholdViolation: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeThresholdViolation--[`++ERC7786OpenBridgeThresholdViolation++`]]
:ERC7786OpenBridgeInvalidExecutionReturnValue: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeInvalidExecutionReturnValue--[`++ERC7786OpenBridgeInvalidExecutionReturnValue++`]]
:RemoteRegistered: pass:normal[xref:#ERC7786OpenBridge-RemoteRegistered-bytes-[`++RemoteRegistered++`]]
:RemoteAlreadyRegistered: pass:normal[xref:#ERC7786OpenBridge-RemoteAlreadyRegistered-bytes-[`++RemoteAlreadyRegistered++`]]
:constructor: pass:normal[xref:#ERC7786OpenBridge-constructor-address-address---uint8-[`++constructor++`]]
:supportsAttribute: pass:normal[xref:#ERC7786OpenBridge-supportsAttribute-bytes4-[`++supportsAttribute++`]]
:sendMessage: pass:normal[xref:#ERC7786OpenBridge-sendMessage-bytes-bytes-bytes---[`++sendMessage++`]]
:receiveMessage: pass:normal[xref:#ERC7786OpenBridge-receiveMessage-bytes32-bytes-bytes-[`++receiveMessage++`]]
:getGateways: pass:normal[xref:#ERC7786OpenBridge-getGateways--[`++getGateways++`]]
:getThreshold: pass:normal[xref:#ERC7786OpenBridge-getThreshold--[`++getThreshold++`]]
:getRemoteBridge: pass:normal[xref:#ERC7786OpenBridge-getRemoteBridge-bytes-[`++getRemoteBridge++`]]
:getRemoteBridge: pass:normal[xref:#ERC7786OpenBridge-getRemoteBridge-bytes2-bytes-[`++getRemoteBridge++`]]
:addGateway: pass:normal[xref:#ERC7786OpenBridge-addGateway-address-[`++addGateway++`]]
:removeGateway: pass:normal[xref:#ERC7786OpenBridge-removeGateway-address-[`++removeGateway++`]]
:setThreshold: pass:normal[xref:#ERC7786OpenBridge-setThreshold-uint8-[`++setThreshold++`]]
:registerRemoteBridge: pass:normal[xref:#ERC7786OpenBridge-registerRemoteBridge-bytes-[`++registerRemoteBridge++`]]
:pause: pass:normal[xref:#ERC7786OpenBridge-pause--[`++pause++`]]
:unpause: pass:normal[xref:#ERC7786OpenBridge-unpause--[`++unpause++`]]
:sweep: pass:normal[xref:#ERC7786OpenBridge-sweep-address-payable-[`++sweep++`]]
:_addGateway: pass:normal[xref:#ERC7786OpenBridge-_addGateway-address-[`++_addGateway++`]]
:_removeGateway: pass:normal[xref:#ERC7786OpenBridge-_removeGateway-address-[`++_removeGateway++`]]
:_setThreshold: pass:normal[xref:#ERC7786OpenBridge-_setThreshold-uint8-[`++_setThreshold++`]]
:_registerRemoteBridge: pass:normal[xref:#ERC7786OpenBridge-_registerRemoteBridge-bytes-[`++_registerRemoteBridge++`]]

[.contract]
[[ERC7786OpenBridge]]
=== `++ERC7786OpenBridge++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/crosschain/ERC7786OpenBridge.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/crosschain/ERC7786OpenBridge.sol";
```

N of M gateway: Sends your message through M independent gateways. It will be delivered to the receiver by an
equivalent bridge on the destination chain if N of the M gateways agree.

[.contract-index]
.Functions
--
* `++constructor(owner_, gateways_, threshold_)++`
* `++supportsAttribute()++`
* `++sendMessage(recipient, payload, attributes)++`
* `++receiveMessage(, sender, payload)++`
* `++getGateways()++`
* `++getThreshold()++`
* `++getRemoteBridge(chain)++`
* `++getRemoteBridge(chainType, chainReference)++`
* `++addGateway(gateway)++`
* `++removeGateway(gateway)++`
* `++setThreshold(newThreshold)++`
* `++registerRemoteBridge(bridge)++`
* `++pause()++`
* `++unpause()++`
* `++sweep(to)++`
* `++_addGateway(gateway)++`
* `++_removeGateway(gateway)++`
* `++_setThreshold(newThreshold)++`
* `++_registerRemoteBridge(bridge)++`

[.contract-subindex-inherited]
.Pausable
* `++paused()++`
* `++_requireNotPaused()++`
* `++_requirePaused()++`
* `++_pause()++`
* `++_unpause()++`

[.contract-subindex-inherited]
.Ownable
* `++owner()++`
* `++_checkOwner()++`
* `++renounceOwnership()++`
* `++transferOwnership(newOwner)++`
* `++_transferOwnership(newOwner)++`

[.contract-subindex-inherited]
.IERC7786Receiver

[.contract-subindex-inherited]
.IERC7786GatewaySource

--

[.contract-index]
.Events
--
* `++OutboxDetails(sendId, outbox)++`
* `++Received(receiveId, gateway)++`
* `++ExecutionSuccess(receiveId)++`
* `++ExecutionFailed(receiveId)++`
* `++GatewayAdded(gateway)++`
* `++GatewayRemoved(gateway)++`
* `++ThresholdUpdated(threshold)++`
* `++RemoteRegistered(remote)++`

[.contract-subindex-inherited]
.Pausable
* `++Paused(account)++`
* `++Unpaused(account)++`

[.contract-subindex-inherited]
.Ownable
* `++OwnershipTransferred(previousOwner, newOwner)++`

[.contract-subindex-inherited]
.IERC7786Receiver

[.contract-subindex-inherited]
.IERC7786GatewaySource
* `++MessageSent(sendId, sender, receiver, payload, value, attributes)++`

--

[.contract-index]
.Errors
--
* `++UnsupportedNativeTransfer()++`
* `++ERC7786OpenBridgeInvalidCrosschainSender()++`
* `++ERC7786OpenBridgeAlreadyExecuted()++`
* `++ERC7786OpenBridgeRemoteNotRegistered(chainType, chainReference)++`
* `++ERC7786OpenBridgeGatewayAlreadyRegistered(gateway)++`
* `++ERC7786OpenBridgeGatewayNotRegistered(gateway)++`
* `++ERC7786OpenBridgeThresholdViolation()++`
* `++ERC7786OpenBridgeInvalidExecutionReturnValue()++`
* `++RemoteAlreadyRegistered(remote)++`

[.contract-subindex-inherited]
.Pausable
* `++EnforcedPause()++`
* `++ExpectedPause()++`

[.contract-subindex-inherited]
.Ownable
* `++OwnableUnauthorizedAccount(account)++`
* `++OwnableInvalidOwner(owner)++`

[.contract-subindex-inherited]
.IERC7786Receiver

[.contract-subindex-inherited]
.IERC7786GatewaySource
* `++UnsupportedAttribute(selector)++`

--

[.contract-item]
[[ERC7786OpenBridge-constructor-address-address---uint8-]]
==== `[.contract-item-name]#++constructor++#++(address owner_, address[] gateways_, uint8 threshold_)++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-supportsAttribute-bytes4-]]
==== `[.contract-item-name]#++supportsAttribute++#++(bytes4) → bool++` [.item-kind]#public#

Getter to check whether an attribute is supported or not.

[.contract-item]
[[ERC7786OpenBridge-sendMessage-bytes-bytes-bytes---]]
==== `[.contract-item-name]#++sendMessage++#++(bytes recipient, bytes payload, bytes[] attributes) → bytes32 sendId++` [.item-kind]#public#

Using memory instead of calldata avoids stack too deep errors

[.contract-item]
[[ERC7786OpenBridge-receiveMessage-bytes32-bytes-bytes-]]
==== `[.contract-item-name]#++receiveMessage++#++(bytes32, bytes sender, bytes payload) → bytes4++` [.item-kind]#public#

This function serves a dual purpose:

It will be called by ERC-7786 gateways with message coming from the the corresponding bridge on the source
chain. These "signals" are tracked until the threshold is reached. At that point the message is sent to the
destination.

It can also be called by anyone (including an ERC-7786 gateway) to retry the execution. This can be useful if
the automatic execution (that is triggered when the threshold is reached) fails, and someone wants to retry it.

When a message is forwarded by a known gateway, a {Received} event is emitted. If a known gateway calls this
function more than once (for a given message), only the first call is counts toward the threshold and emits an
{Received} event.

This function revert if:

* the message is not properly formatted or does not originate from the registered bridge on the source
  chain.
* someone tries re-execute a message that was already successfully delivered. This includes gateways that call
  this function a second time with a message that was already executed.
* the execution of the message (on the {IERC7786Receiver} receiver) is successful but fails to return the
  executed value.

This function does not revert if:

* A known gateway delivers a message for the first time, and that message was already executed. In that case
  the message is NOT re-executed, and the correct "magic value" is returned.
* The execution of the message (on the {IERC7786Receiver} receiver) reverts. In that case a {ExecutionFailed}
  event is emitted.

This function emits:

* {Received} when a known ERC-7786 gateway delivers a message for the first time.
* {ExecutionSuccess} when a message is successfully delivered to the receiver.
* {ExecutionFailed} when a message delivery to the receiver reverted (for example because of OOG error).

NOTE: interface requires this function to be payable. Even if we don't expect any value, a gateway may pass
some value for unknown reason. In that case we want to register this gateway having delivered the message and
not revert. Any value accrued that way can be recovered by the admin using the {sweep} function.

[.contract-item]
[[ERC7786OpenBridge-getGateways--]]
==== `[.contract-item-name]#++getGateways++#++() → address[]++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-getThreshold--]]
==== `[.contract-item-name]#++getThreshold++#++() → uint8++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-getRemoteBridge-bytes-]]
==== `[.contract-item-name]#++getRemoteBridge++#++(bytes chain) → bytes++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-getRemoteBridge-bytes2-bytes-]]
==== `[.contract-item-name]#++getRemoteBridge++#++(bytes2 chainType, bytes chainReference) → bytes++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-addGateway-address-]]
==== `[.contract-item-name]#++addGateway++#++(address gateway)++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-removeGateway-address-]]
==== `[.contract-item-name]#++removeGateway++#++(address gateway)++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-setThreshold-uint8-]]
==== `[.contract-item-name]#++setThreshold++#++(uint8 newThreshold)++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-registerRemoteBridge-bytes-]]
==== `[.contract-item-name]#++registerRemoteBridge++#++(bytes bridge)++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-pause--]]
==== `[.contract-item-name]#++pause++#++()++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-unpause--]]
==== `[.contract-item-name]#++unpause++#++()++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-sweep-address-payable-]]
==== `[.contract-item-name]#++sweep++#++(address payable to)++` [.item-kind]#public#

Recovery method in case value is ever received through {receiveMessage}

[.contract-item]
[[ERC7786OpenBridge-_addGateway-address-]]
==== `[.contract-item-name]#++_addGateway++#++(address gateway)++` [.item-kind]#internal#

[.contract-item]
[[ERC7786OpenBridge-_removeGateway-address-]]
==== `[.contract-item-name]#++_removeGateway++#++(address gateway)++` [.item-kind]#internal#

[.contract-item]
[[ERC7786OpenBridge-_setThreshold-uint8-]]
==== `[.contract-item-name]#++_setThreshold++#++(uint8 newThreshold)++` [.item-kind]#internal#

[.contract-item]
[[ERC7786OpenBridge-_registerRemoteBridge-bytes-]]
==== `[.contract-item-name]#++_registerRemoteBridge++#++(bytes bridge)++` [.item-kind]#internal#

[.contract-item]
[[ERC7786OpenBridge-OutboxDetails-bytes32-struct-ERC7786OpenBridge-Outbox---]]
==== `[.contract-item-name]#++OutboxDetails++#++(bytes32 indexed sendId, struct ERC7786OpenBridge.Outbox[] outbox)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-Received-bytes32-address-]]
==== `[.contract-item-name]#++Received++#++(bytes32 indexed receiveId, address gateway)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-ExecutionSuccess-bytes32-]]
==== `[.contract-item-name]#++ExecutionSuccess++#++(bytes32 indexed receiveId)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-ExecutionFailed-bytes32-]]
==== `[.contract-item-name]#++ExecutionFailed++#++(bytes32 indexed receiveId)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-GatewayAdded-address-]]
==== `[.contract-item-name]#++GatewayAdded++#++(address indexed gateway)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-GatewayRemoved-address-]]
==== `[.contract-item-name]#++GatewayRemoved++#++(address indexed gateway)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-ThresholdUpdated-uint8-]]
==== `[.contract-item-name]#++ThresholdUpdated++#++(uint8 threshold)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-RemoteRegistered-bytes-]]
==== `[.contract-item-name]#++RemoteRegistered++#++(bytes remote)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-UnsupportedNativeTransfer--]]
==== `[.contract-item-name]#++UnsupportedNativeTransfer++#++()++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeInvalidCrosschainSender--]]
==== `[.contract-item-name]#++ERC7786OpenBridgeInvalidCrosschainSender++#++()++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeAlreadyExecuted--]]
==== `[.contract-item-name]#++ERC7786OpenBridgeAlreadyExecuted++#++()++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeRemoteNotRegistered-bytes2-bytes-]]
==== `[.contract-item-name]#++ERC7786OpenBridgeRemoteNotRegistered++#++(bytes2 chainType, bytes chainReference)++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeGatewayAlreadyRegistered-address-]]
==== `[.contract-item-name]#++ERC7786OpenBridgeGatewayAlreadyRegistered++#++(address gateway)++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeGatewayNotRegistered-address-]]
==== `[.contract-item-name]#++ERC7786OpenBridgeGatewayNotRegistered++#++(address gateway)++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeThresholdViolation--]]
==== `[.contract-item-name]#++ERC7786OpenBridgeThresholdViolation++#++()++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeInvalidExecutionReturnValue--]]
==== `[.contract-item-name]#++ERC7786OpenBridgeInvalidExecutionReturnValue++#++()++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-RemoteAlreadyRegistered-bytes-]]
==== `[.contract-item-name]#++RemoteAlreadyRegistered++#++(bytes remote)++` [.item-kind]#error#

== Clients

:ERC7786ReceiverInvalidGateway: pass:normal[xref:#ERC7786Receiver-ERC7786ReceiverInvalidGateway-address-[`++ERC7786ReceiverInvalidGateway++`]]
:ERC7786ReceivePassiveModeValue: pass:normal[xref:#ERC7786Receiver-ERC7786ReceivePassiveModeValue--[`++ERC7786ReceivePassiveModeValue++`]]
:receiveMessage: pass:normal[xref:#ERC7786Receiver-receiveMessage-bytes32-bytes-bytes-[`++receiveMessage++`]]
:_isKnownGateway: pass:normal[xref:#ERC7786Receiver-_isKnownGateway-address-[`++_isKnownGateway++`]]
:_processMessage: pass:normal[xref:#ERC7786Receiver-_processMessage-address-bytes32-bytes-bytes-[`++_processMessage++`]]

[.contract]
[[ERC7786Receiver]]
=== `++ERC7786Receiver++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/crosschain/utils/ERC7786Receiver.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/crosschain/utils/ERC7786Receiver.sol";
```

Base implementation of an ERC-7786 compliant cross-chain message receiver.

This abstract contract exposes the `receiveMessage` function that is used for communication with (one or multiple)
destination gateways. This contract leaves two functions unimplemented:

{_isKnownGateway}, an internal getter used to verify whether an address is recognised by the contract as a valid
ERC-7786 destination gateway. One or multiple gateway can be supported. Note that any malicious address for which
this function returns true would be able to impersonate any account on any other chain sending any message.

{_processMessage}, the internal function that will be called with any message that has been validated.

[.contract-index]
.Functions
--
* `++receiveMessage(receiveId, sender, payload)++`
* `++_isKnownGateway(instance)++`
* `++_processMessage(gateway, receiveId, sender, payload)++`

[.contract-subindex-inherited]
.IERC7786Receiver

--

[.contract-index]
.Errors
--
* `++ERC7786ReceiverInvalidGateway(gateway)++`
* `++ERC7786ReceivePassiveModeValue()++`

[.contract-subindex-inherited]
.IERC7786Receiver

--

[.contract-item]
[[ERC7786Receiver-receiveMessage-bytes32-bytes-bytes-]]
==== `[.contract-item-name]#++receiveMessage++#++(bytes32 receiveId, bytes sender, bytes payload) → bytes4++` [.item-kind]#public#

Endpoint for receiving cross-chain message.

This function may be called directly by the gateway.

[.contract-item]
[[ERC7786Receiver-_isKnownGateway-address-]]
==== `[.contract-item-name]#++_isKnownGateway++#++(address instance) → bool++` [.item-kind]#internal#

Virtual getter that returns whether an address is a valid ERC-7786 gateway.

[.contract-item]
[[ERC7786Receiver-_processMessage-address-bytes32-bytes-bytes-]]
==== `[.contract-item-name]#++_processMessage++#++(address gateway, bytes32 receiveId, bytes sender, bytes payload)++` [.item-kind]#internal#

Virtual function that should contain the logic to execute when a cross-chain message is received.

[.contract-item]
[[ERC7786Receiver-ERC7786ReceiverInvalidGateway-address-]]
==== `[.contract-item-name]#++ERC7786ReceiverInvalidGateway++#++(address gateway)++` [.item-kind]#error#

[.contract-item]
[[ERC7786Receiver-ERC7786ReceivePassiveModeValue--]]
==== `[.contract-item-name]#++ERC7786ReceivePassiveModeValue++#++()++` [.item-kind]#error#

== Adapters

=== Axelar

