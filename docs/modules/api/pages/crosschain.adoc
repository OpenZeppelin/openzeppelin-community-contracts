:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:ERC7786Receiver: pass:normal[xref:crosschain.adoc#ERC7786Receiver[`ERC7786Receiver`]]
:ERC7786OpenBridge: pass:normal[xref:crosschain.adoc#ERC7786OpenBridge[`ERC7786OpenBridge`]]
:AxelarGatewayBase: pass:normal[xref:crosschain.adoc#AxelarGatewayBase[`AxelarGatewayBase`]]
:AxelarGatewaySource: pass:normal[xref:crosschain.adoc#AxelarGatewaySource[`AxelarGatewaySource`]]
:AxelarGatewayDestination: pass:normal[xref:crosschain.adoc#AxelarGatewayDestination[`AxelarGatewayDestination`]]
:AxelarGatewayDuplex: pass:normal[xref:crosschain.adoc#AxelarGatewayDuplex[`AxelarGatewayDuplex`]]
:IERC7786Receiver: pass:normal[xref:interfaces.adoc#IERC7786Receiver[`IERC7786Receiver`]]
:IERC7786Receiver: pass:normal[xref:interfaces.adoc#IERC7786Receiver[`IERC7786Receiver`]]
= Crosschain

[.readme-notice]
NOTE: This document is better viewed at https://docs.openzeppelin.com/community-contracts/api/crosschain

Gateways are contracts that enable cross-chain communication. These can either be a message source or a destination according to ERC-7786.

 * {ERC7786Receiver}: ERC-7786 cross-chain message receiver.
 * {ERC7786OpenBridge}: ERC-7786 "N out of M" gateway. Sends a message through M gateways and executes on the destination if N received it.

Developers can access interoperability protocols through gateway adapters. The library includes the following gateway adapters:

 * {AxelarGatewayBase}: Core gateway logic for the https://www.axelar.network/[Axelar] adapter.
 * {AxelarGatewaySource}: ERC-7786 source gateway adapter (sending side) for Axelar.
 * {AxelarGatewayDestination}: ERC-7786 destination gateway adapter (receiving side) for Axelar.
 * {AxelarGatewayDuplex}: ERC-7786 gateway adapter that operates in both directions (i.e. send and receive messages) using the Axelar network.

== Gateways

:Outbox: pass:normal[xref:#ERC7786OpenBridge-Outbox[`++Outbox++`]]
:Tracker: pass:normal[xref:#ERC7786OpenBridge-Tracker[`++Tracker++`]]
:OutboxDetails: pass:normal[xref:#ERC7786OpenBridge-OutboxDetails-bytes32-struct-ERC7786OpenBridge-Outbox---[`++OutboxDetails++`]]
:Received: pass:normal[xref:#ERC7786OpenBridge-Received-bytes32-address-[`++Received++`]]
:ExecutionSuccess: pass:normal[xref:#ERC7786OpenBridge-ExecutionSuccess-bytes32-[`++ExecutionSuccess++`]]
:ExecutionFailed: pass:normal[xref:#ERC7786OpenBridge-ExecutionFailed-bytes32-[`++ExecutionFailed++`]]
:GatewayAdded: pass:normal[xref:#ERC7786OpenBridge-GatewayAdded-address-[`++GatewayAdded++`]]
:GatewayRemoved: pass:normal[xref:#ERC7786OpenBridge-GatewayRemoved-address-[`++GatewayRemoved++`]]
:ThresholdUpdated: pass:normal[xref:#ERC7786OpenBridge-ThresholdUpdated-uint8-[`++ThresholdUpdated++`]]
:UnsupportedNativeTransfer: pass:normal[xref:#ERC7786OpenBridge-UnsupportedNativeTransfer--[`++UnsupportedNativeTransfer++`]]
:ERC7786OpenBridgeInvalidCrosschainSender: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeInvalidCrosschainSender--[`++ERC7786OpenBridgeInvalidCrosschainSender++`]]
:ERC7786OpenBridgeAlreadyExecuted: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeAlreadyExecuted--[`++ERC7786OpenBridgeAlreadyExecuted++`]]
:ERC7786OpenBridgeRemoteNotRegistered: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeRemoteNotRegistered-bytes2-bytes-[`++ERC7786OpenBridgeRemoteNotRegistered++`]]
:ERC7786OpenBridgeGatewayAlreadyRegistered: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeGatewayAlreadyRegistered-address-[`++ERC7786OpenBridgeGatewayAlreadyRegistered++`]]
:ERC7786OpenBridgeGatewayNotRegistered: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeGatewayNotRegistered-address-[`++ERC7786OpenBridgeGatewayNotRegistered++`]]
:ERC7786OpenBridgeThresholdViolation: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeThresholdViolation--[`++ERC7786OpenBridgeThresholdViolation++`]]
:ERC7786OpenBridgeInvalidExecutionReturnValue: pass:normal[xref:#ERC7786OpenBridge-ERC7786OpenBridgeInvalidExecutionReturnValue--[`++ERC7786OpenBridgeInvalidExecutionReturnValue++`]]
:RemoteRegistered: pass:normal[xref:#ERC7786OpenBridge-RemoteRegistered-bytes-[`++RemoteRegistered++`]]
:RemoteAlreadyRegistered: pass:normal[xref:#ERC7786OpenBridge-RemoteAlreadyRegistered-bytes-[`++RemoteAlreadyRegistered++`]]
:constructor: pass:normal[xref:#ERC7786OpenBridge-constructor-address-address---uint8-[`++constructor++`]]
:supportsAttribute: pass:normal[xref:#ERC7786OpenBridge-supportsAttribute-bytes4-[`++supportsAttribute++`]]
:sendMessage: pass:normal[xref:#ERC7786OpenBridge-sendMessage-bytes-bytes-bytes---[`++sendMessage++`]]
:executeMessage: pass:normal[xref:#ERC7786OpenBridge-executeMessage-bytes32-bytes-bytes-bytes---[`++executeMessage++`]]
:getGateways: pass:normal[xref:#ERC7786OpenBridge-getGateways--[`++getGateways++`]]
:getThreshold: pass:normal[xref:#ERC7786OpenBridge-getThreshold--[`++getThreshold++`]]
:getRemoteBridge: pass:normal[xref:#ERC7786OpenBridge-getRemoteBridge-bytes-[`++getRemoteBridge++`]]
:getRemoteBridge: pass:normal[xref:#ERC7786OpenBridge-getRemoteBridge-bytes2-bytes-[`++getRemoteBridge++`]]
:addGateway: pass:normal[xref:#ERC7786OpenBridge-addGateway-address-[`++addGateway++`]]
:removeGateway: pass:normal[xref:#ERC7786OpenBridge-removeGateway-address-[`++removeGateway++`]]
:setThreshold: pass:normal[xref:#ERC7786OpenBridge-setThreshold-uint8-[`++setThreshold++`]]
:registerRemoteBridge: pass:normal[xref:#ERC7786OpenBridge-registerRemoteBridge-bytes-[`++registerRemoteBridge++`]]
:pause: pass:normal[xref:#ERC7786OpenBridge-pause--[`++pause++`]]
:unpause: pass:normal[xref:#ERC7786OpenBridge-unpause--[`++unpause++`]]
:sweep: pass:normal[xref:#ERC7786OpenBridge-sweep-address-payable-[`++sweep++`]]
:_addGateway: pass:normal[xref:#ERC7786OpenBridge-_addGateway-address-[`++_addGateway++`]]
:_removeGateway: pass:normal[xref:#ERC7786OpenBridge-_removeGateway-address-[`++_removeGateway++`]]
:_setThreshold: pass:normal[xref:#ERC7786OpenBridge-_setThreshold-uint8-[`++_setThreshold++`]]
:_registerRemoteBridge: pass:normal[xref:#ERC7786OpenBridge-_registerRemoteBridge-bytes-[`++_registerRemoteBridge++`]]

[.contract]
[[ERC7786OpenBridge]]
=== `++ERC7786OpenBridge++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/crosschain/ERC7786OpenBridge.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/crosschain/ERC7786OpenBridge.sol";
```

N of M gateway: Sends your message through M independent gateways. It will be delivered to the receiver by an
equivalent bridge on the destination chain if N of the M gateways agree.

[.contract-index]
.Functions
--
* `++constructor(owner_, gateways_, threshold_)++`
* `++supportsAttribute()++`
* `++sendMessage(recipient, payload, attributes)++`
* `++executeMessage(, sender, payload, attributes)++`
* `++getGateways()++`
* `++getThreshold()++`
* `++getRemoteBridge(chain)++`
* `++getRemoteBridge(chainType, chainReference)++`
* `++addGateway(gateway)++`
* `++removeGateway(gateway)++`
* `++setThreshold(newThreshold)++`
* `++registerRemoteBridge(bridge)++`
* `++pause()++`
* `++unpause()++`
* `++sweep(to)++`
* `++_addGateway(gateway)++`
* `++_removeGateway(gateway)++`
* `++_setThreshold(newThreshold)++`
* `++_registerRemoteBridge(bridge)++`

[.contract-subindex-inherited]
.Pausable
* `++paused()++`
* `++_requireNotPaused()++`
* `++_requirePaused()++`
* `++_pause()++`
* `++_unpause()++`

[.contract-subindex-inherited]
.Ownable
* `++owner()++`
* `++_checkOwner()++`
* `++renounceOwnership()++`
* `++transferOwnership(newOwner)++`
* `++_transferOwnership(newOwner)++`

[.contract-subindex-inherited]
.IERC7786Receiver

[.contract-subindex-inherited]
.IERC7786GatewaySource

--

[.contract-index]
.Events
--
* `++OutboxDetails(sendId, outbox)++`
* `++Received(receiveId, gateway)++`
* `++ExecutionSuccess(receiveId)++`
* `++ExecutionFailed(receiveId)++`
* `++GatewayAdded(gateway)++`
* `++GatewayRemoved(gateway)++`
* `++ThresholdUpdated(threshold)++`
* `++RemoteRegistered(remote)++`

[.contract-subindex-inherited]
.Pausable
* `++Paused(account)++`
* `++Unpaused(account)++`

[.contract-subindex-inherited]
.Ownable
* `++OwnershipTransferred(previousOwner, newOwner)++`

[.contract-subindex-inherited]
.IERC7786Receiver

[.contract-subindex-inherited]
.IERC7786GatewaySource
* `++MessageSent(sendId, sender, receiver, payload, value, attributes)++`

--

[.contract-index]
.Errors
--
* `++UnsupportedNativeTransfer()++`
* `++ERC7786OpenBridgeInvalidCrosschainSender()++`
* `++ERC7786OpenBridgeAlreadyExecuted()++`
* `++ERC7786OpenBridgeRemoteNotRegistered(chainType, chainReference)++`
* `++ERC7786OpenBridgeGatewayAlreadyRegistered(gateway)++`
* `++ERC7786OpenBridgeGatewayNotRegistered(gateway)++`
* `++ERC7786OpenBridgeThresholdViolation()++`
* `++ERC7786OpenBridgeInvalidExecutionReturnValue()++`
* `++RemoteAlreadyRegistered(remote)++`

[.contract-subindex-inherited]
.Pausable
* `++EnforcedPause()++`
* `++ExpectedPause()++`

[.contract-subindex-inherited]
.Ownable
* `++OwnableUnauthorizedAccount(account)++`
* `++OwnableInvalidOwner(owner)++`

[.contract-subindex-inherited]
.IERC7786Receiver

[.contract-subindex-inherited]
.IERC7786GatewaySource
* `++UnsupportedAttribute(selector)++`

--

[.contract-item]
[[ERC7786OpenBridge-constructor-address-address---uint8-]]
==== `[.contract-item-name]#++constructor++#++(address owner_, address[] gateways_, uint8 threshold_)++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-supportsAttribute-bytes4-]]
==== `[.contract-item-name]#++supportsAttribute++#++(bytes4) → bool++` [.item-kind]#public#

Getter to check whether an attribute is supported or not.

[.contract-item]
[[ERC7786OpenBridge-sendMessage-bytes-bytes-bytes---]]
==== `[.contract-item-name]#++sendMessage++#++(bytes recipient, bytes payload, bytes[] attributes) → bytes32 sendId++` [.item-kind]#public#

Using memory instead of calldata avoids stack too deep errors

[.contract-item]
[[ERC7786OpenBridge-executeMessage-bytes32-bytes-bytes-bytes---]]
==== `[.contract-item-name]#++executeMessage++#++(bytes32, bytes sender, bytes payload, bytes[] attributes) → bytes4++` [.item-kind]#public#

This function serves a dual purpose:

It will be called by ERC-7786 gateways with message coming from the the corresponding bridge on the source
chain. These "signals" are tracked until the threshold is reached. At that point the message is sent to the
destination.

It can also be called by anyone (including an ERC-7786 gateway) to retry the execution. This can be useful if
the automatic execution (that is triggered when the threshold is reached) fails, and someone wants to retry it.

When a message is forwarded by a known gateway, a {Received} event is emitted. If a known gateway calls this
function more than once (for a given message), only the first call is counts toward the threshold and emits an
{Received} event.

This function revert if:

* the message is not properly formatted or does not originate from the registered bridge on the source
  chain.
* someone tries re-execute a message that was already successfully delivered. This includes gateways that call
  this function a second time with a message that was already executed.
* the execution of the message (on the {IERC7786Receiver} receiver) is successful but fails to return the
  executed value.

This function does not revert if:

* A known gateway delivers a message for the first time, and that message was already executed. In that case
  the message is NOT re-executed, and the correct "magic value" is returned.
* The execution of the message (on the {IERC7786Receiver} receiver) reverts. In that case a {ExecutionFailed}
  event is emitted.

This function emits:

* {Received} when a known ERC-7786 gateway delivers a message for the first time.
* {ExecutionSuccess} when a message is successfully delivered to the receiver.
* {ExecutionFailed} when a message delivery to the receiver reverted (for example because of OOG error).

NOTE: interface requires this function to be payable. Even if we don't expect any value, a gateway may pass
some value for unknown reason. In that case we want to register this gateway having delivered the message and
not revert. Any value accrued that way can be recovered by the admin using the {sweep} function.

[.contract-item]
[[ERC7786OpenBridge-getGateways--]]
==== `[.contract-item-name]#++getGateways++#++() → address[]++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-getThreshold--]]
==== `[.contract-item-name]#++getThreshold++#++() → uint8++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-getRemoteBridge-bytes-]]
==== `[.contract-item-name]#++getRemoteBridge++#++(bytes chain) → bytes++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-getRemoteBridge-bytes2-bytes-]]
==== `[.contract-item-name]#++getRemoteBridge++#++(bytes2 chainType, bytes chainReference) → bytes++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-addGateway-address-]]
==== `[.contract-item-name]#++addGateway++#++(address gateway)++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-removeGateway-address-]]
==== `[.contract-item-name]#++removeGateway++#++(address gateway)++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-setThreshold-uint8-]]
==== `[.contract-item-name]#++setThreshold++#++(uint8 newThreshold)++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-registerRemoteBridge-bytes-]]
==== `[.contract-item-name]#++registerRemoteBridge++#++(bytes bridge)++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-pause--]]
==== `[.contract-item-name]#++pause++#++()++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-unpause--]]
==== `[.contract-item-name]#++unpause++#++()++` [.item-kind]#public#

[.contract-item]
[[ERC7786OpenBridge-sweep-address-payable-]]
==== `[.contract-item-name]#++sweep++#++(address payable to)++` [.item-kind]#public#

Recovery method in case value is ever received through {executeMessage}

[.contract-item]
[[ERC7786OpenBridge-_addGateway-address-]]
==== `[.contract-item-name]#++_addGateway++#++(address gateway)++` [.item-kind]#internal#

[.contract-item]
[[ERC7786OpenBridge-_removeGateway-address-]]
==== `[.contract-item-name]#++_removeGateway++#++(address gateway)++` [.item-kind]#internal#

[.contract-item]
[[ERC7786OpenBridge-_setThreshold-uint8-]]
==== `[.contract-item-name]#++_setThreshold++#++(uint8 newThreshold)++` [.item-kind]#internal#

[.contract-item]
[[ERC7786OpenBridge-_registerRemoteBridge-bytes-]]
==== `[.contract-item-name]#++_registerRemoteBridge++#++(bytes bridge)++` [.item-kind]#internal#

[.contract-item]
[[ERC7786OpenBridge-OutboxDetails-bytes32-struct-ERC7786OpenBridge-Outbox---]]
==== `[.contract-item-name]#++OutboxDetails++#++(bytes32 indexed sendId, struct ERC7786OpenBridge.Outbox[] outbox)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-Received-bytes32-address-]]
==== `[.contract-item-name]#++Received++#++(bytes32 indexed receiveId, address gateway)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-ExecutionSuccess-bytes32-]]
==== `[.contract-item-name]#++ExecutionSuccess++#++(bytes32 indexed receiveId)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-ExecutionFailed-bytes32-]]
==== `[.contract-item-name]#++ExecutionFailed++#++(bytes32 indexed receiveId)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-GatewayAdded-address-]]
==== `[.contract-item-name]#++GatewayAdded++#++(address indexed gateway)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-GatewayRemoved-address-]]
==== `[.contract-item-name]#++GatewayRemoved++#++(address indexed gateway)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-ThresholdUpdated-uint8-]]
==== `[.contract-item-name]#++ThresholdUpdated++#++(uint8 threshold)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-RemoteRegistered-bytes-]]
==== `[.contract-item-name]#++RemoteRegistered++#++(bytes remote)++` [.item-kind]#event#

[.contract-item]
[[ERC7786OpenBridge-UnsupportedNativeTransfer--]]
==== `[.contract-item-name]#++UnsupportedNativeTransfer++#++()++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeInvalidCrosschainSender--]]
==== `[.contract-item-name]#++ERC7786OpenBridgeInvalidCrosschainSender++#++()++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeAlreadyExecuted--]]
==== `[.contract-item-name]#++ERC7786OpenBridgeAlreadyExecuted++#++()++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeRemoteNotRegistered-bytes2-bytes-]]
==== `[.contract-item-name]#++ERC7786OpenBridgeRemoteNotRegistered++#++(bytes2 chainType, bytes chainReference)++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeGatewayAlreadyRegistered-address-]]
==== `[.contract-item-name]#++ERC7786OpenBridgeGatewayAlreadyRegistered++#++(address gateway)++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeGatewayNotRegistered-address-]]
==== `[.contract-item-name]#++ERC7786OpenBridgeGatewayNotRegistered++#++(address gateway)++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeThresholdViolation--]]
==== `[.contract-item-name]#++ERC7786OpenBridgeThresholdViolation++#++()++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-ERC7786OpenBridgeInvalidExecutionReturnValue--]]
==== `[.contract-item-name]#++ERC7786OpenBridgeInvalidExecutionReturnValue++#++()++` [.item-kind]#error#

[.contract-item]
[[ERC7786OpenBridge-RemoteAlreadyRegistered-bytes-]]
==== `[.contract-item-name]#++RemoteAlreadyRegistered++#++(bytes remote)++` [.item-kind]#error#

== Clients

:ERC7786ReceiverInvalidGateway: pass:normal[xref:#ERC7786Receiver-ERC7786ReceiverInvalidGateway-address-[`++ERC7786ReceiverInvalidGateway++`]]
:ERC7786ReceivePassiveModeValue: pass:normal[xref:#ERC7786Receiver-ERC7786ReceivePassiveModeValue--[`++ERC7786ReceivePassiveModeValue++`]]
:executeMessage: pass:normal[xref:#ERC7786Receiver-executeMessage-bytes32-bytes-bytes-bytes---[`++executeMessage++`]]
:_isKnownGateway: pass:normal[xref:#ERC7786Receiver-_isKnownGateway-address-[`++_isKnownGateway++`]]
:_processMessage: pass:normal[xref:#ERC7786Receiver-_processMessage-address-bytes32-bytes-bytes-bytes---[`++_processMessage++`]]

[.contract]
[[ERC7786Receiver]]
=== `++ERC7786Receiver++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/crosschain/utils/ERC7786Receiver.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/crosschain/utils/ERC7786Receiver.sol";
```

Base implementation of an ERC-7786 compliant cross-chain message receiver.

This abstract contract exposes the `executeMessage` function that is used for communication with (one or multiple)
destination gateways. This contract leaves two functions unimplemented:

{_isKnownGateway}, an internal getter used to verify whether an address is recognised by the contract as a valid
ERC-7786 destination gateway. One or multiple gateway can be supported. Note that any malicious address for which
this function returns true would be able to impersonate any account on any other chain sending any message.

{_processMessage}, the internal function that will be called with any message that has been validated.

[.contract-index]
.Functions
--
* `++executeMessage(receiveId, sender, payload, attributes)++`
* `++_isKnownGateway(instance)++`
* `++_processMessage(gateway, receiveId, sender, payload, attributes)++`

[.contract-subindex-inherited]
.IERC7786Receiver

--

[.contract-index]
.Errors
--
* `++ERC7786ReceiverInvalidGateway(gateway)++`
* `++ERC7786ReceivePassiveModeValue()++`

[.contract-subindex-inherited]
.IERC7786Receiver

--

[.contract-item]
[[ERC7786Receiver-executeMessage-bytes32-bytes-bytes-bytes---]]
==== `[.contract-item-name]#++executeMessage++#++(bytes32 receiveId, bytes sender, bytes payload, bytes[] attributes) → bytes4++` [.item-kind]#public#

Endpoint for receiving cross-chain message.

This function may be called directly by the gateway.

[.contract-item]
[[ERC7786Receiver-_isKnownGateway-address-]]
==== `[.contract-item-name]#++_isKnownGateway++#++(address instance) → bool++` [.item-kind]#internal#

Virtual getter that returns whether an address is a valid ERC-7786 gateway.

[.contract-item]
[[ERC7786Receiver-_processMessage-address-bytes32-bytes-bytes-bytes---]]
==== `[.contract-item-name]#++_processMessage++#++(address gateway, bytes32 receiveId, bytes sender, bytes payload, bytes[] attributes)++` [.item-kind]#internal#

Virtual function that should contain the logic to execute when a cross-chain message is received.

[.contract-item]
[[ERC7786Receiver-ERC7786ReceiverInvalidGateway-address-]]
==== `[.contract-item-name]#++ERC7786ReceiverInvalidGateway++#++(address gateway)++` [.item-kind]#error#

[.contract-item]
[[ERC7786Receiver-ERC7786ReceivePassiveModeValue--]]
==== `[.contract-item-name]#++ERC7786ReceivePassiveModeValue++#++()++` [.item-kind]#error#

== Adapters

=== Axelar

:_axelarGateway: pass:normal[xref:#AxelarGatewayBase-_axelarGateway-contract-IAxelarGateway[`++_axelarGateway++`]]
:RegisteredRemoteGateway: pass:normal[xref:#AxelarGatewayBase-RegisteredRemoteGateway-bytes-[`++RegisteredRemoteGateway++`]]
:RegisteredChainEquivalence: pass:normal[xref:#AxelarGatewayBase-RegisteredChainEquivalence-bytes-string-[`++RegisteredChainEquivalence++`]]
:UnsupportedERC7930Chain: pass:normal[xref:#AxelarGatewayBase-UnsupportedERC7930Chain-bytes-[`++UnsupportedERC7930Chain++`]]
:UnsupportedAxelarChain: pass:normal[xref:#AxelarGatewayBase-UnsupportedAxelarChain-string-[`++UnsupportedAxelarChain++`]]
:InvalidChainIdentifier: pass:normal[xref:#AxelarGatewayBase-InvalidChainIdentifier-bytes-[`++InvalidChainIdentifier++`]]
:ChainEquivalenceAlreadyRegistered: pass:normal[xref:#AxelarGatewayBase-ChainEquivalenceAlreadyRegistered-bytes-string-[`++ChainEquivalenceAlreadyRegistered++`]]
:RemoteGatewayAlreadyRegistered: pass:normal[xref:#AxelarGatewayBase-RemoteGatewayAlreadyRegistered-bytes2-bytes-[`++RemoteGatewayAlreadyRegistered++`]]
:constructor: pass:normal[xref:#AxelarGatewayBase-constructor-contract-IAxelarGateway-[`++constructor++`]]
:getAxelarChain: pass:normal[xref:#AxelarGatewayBase-getAxelarChain-bytes-[`++getAxelarChain++`]]
:getErc7930Chain: pass:normal[xref:#AxelarGatewayBase-getErc7930Chain-string-[`++getErc7930Chain++`]]
:getRemoteGateway: pass:normal[xref:#AxelarGatewayBase-getRemoteGateway-bytes-[`++getRemoteGateway++`]]
:getRemoteGateway: pass:normal[xref:#AxelarGatewayBase-getRemoteGateway-bytes2-bytes-[`++getRemoteGateway++`]]
:registerChainEquivalence: pass:normal[xref:#AxelarGatewayBase-registerChainEquivalence-bytes-string-[`++registerChainEquivalence++`]]
:registerRemoteGateway: pass:normal[xref:#AxelarGatewayBase-registerRemoteGateway-bytes-[`++registerRemoteGateway++`]]

[.contract]
[[AxelarGatewayBase]]
=== `++AxelarGatewayBase++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/crosschain/axelar/AxelarGatewayBase.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/crosschain/axelar/AxelarGatewayBase.sol";
```

Base implementation of a cross-chain gateway adapter for the Axelar Network.

This contract allows developers to register equivalence between chains (i.e. ERC-7930 chain type and reference
to Axelar chain identifiers) and remote gateways (i.e. gateways on other chains) to facilitate cross-chain
communication.

[.contract-index]
.Functions
--
* `++constructor(_gateway)++`
* `++getAxelarChain(input)++`
* `++getErc7930Chain(input)++`
* `++getRemoteGateway(chain)++`
* `++getRemoteGateway(chainType, chainReference)++`
* `++registerChainEquivalence(chain, axelar)++`
* `++registerRemoteGateway(remote)++`

[.contract-subindex-inherited]
.Ownable
* `++owner()++`
* `++_checkOwner()++`
* `++renounceOwnership()++`
* `++transferOwnership(newOwner)++`
* `++_transferOwnership(newOwner)++`

--

[.contract-index]
.Events
--
* `++RegisteredRemoteGateway(remote)++`
* `++RegisteredChainEquivalence(erc7930binary, axelar)++`

[.contract-subindex-inherited]
.Ownable
* `++OwnershipTransferred(previousOwner, newOwner)++`

--

[.contract-index]
.Errors
--
* `++UnsupportedERC7930Chain(erc7930binary)++`
* `++UnsupportedAxelarChain(axelar)++`
* `++InvalidChainIdentifier(erc7930binary)++`
* `++ChainEquivalenceAlreadyRegistered(erc7930binary, axelar)++`
* `++RemoteGatewayAlreadyRegistered(chainType, chainReference)++`

[.contract-subindex-inherited]
.Ownable
* `++OwnableUnauthorizedAccount(account)++`
* `++OwnableInvalidOwner(owner)++`

--

[.contract-index]
.Internal Variables
--
* `++contract IAxelarGateway  _axelarGateway++`

[.contract-subindex-inherited]
.Ownable

--

[.contract-item]
[[AxelarGatewayBase-constructor-contract-IAxelarGateway-]]
==== `[.contract-item-name]#++constructor++#++(contract IAxelarGateway _gateway)++` [.item-kind]#internal#

Sets the local gateway address (i.e. Axelar's official gateway for the current chain).

[.contract-item]
[[AxelarGatewayBase-getAxelarChain-bytes-]]
==== `[.contract-item-name]#++getAxelarChain++#++(bytes input) → string output++` [.item-kind]#public#

Returns the equivalent chain given an id that can be either either a binary interoperable address or an Axelar network identifier.

[.contract-item]
[[AxelarGatewayBase-getErc7930Chain-string-]]
==== `[.contract-item-name]#++getErc7930Chain++#++(string input) → bytes output++` [.item-kind]#public#

[.contract-item]
[[AxelarGatewayBase-getRemoteGateway-bytes-]]
==== `[.contract-item-name]#++getRemoteGateway++#++(bytes chain) → bytes++` [.item-kind]#public#

Returns the address of the remote gateway for a given chainType and chainReference.

[.contract-item]
[[AxelarGatewayBase-getRemoteGateway-bytes2-bytes-]]
==== `[.contract-item-name]#++getRemoteGateway++#++(bytes2 chainType, bytes chainReference) → bytes++` [.item-kind]#public#

[.contract-item]
[[AxelarGatewayBase-registerChainEquivalence-bytes-string-]]
==== `[.contract-item-name]#++registerChainEquivalence++#++(bytes chain, string axelar)++` [.item-kind]#public#

Registers a chain equivalence between a binary interoperable address an Axelar network identifier.

[.contract-item]
[[AxelarGatewayBase-registerRemoteGateway-bytes-]]
==== `[.contract-item-name]#++registerRemoteGateway++#++(bytes remote)++` [.item-kind]#public#

Registers the address of a remote gateway.

[.contract-item]
[[AxelarGatewayBase-RegisteredRemoteGateway-bytes-]]
==== `[.contract-item-name]#++RegisteredRemoteGateway++#++(bytes remote)++` [.item-kind]#event#

A remote gateway has been registered for a chain.

[.contract-item]
[[AxelarGatewayBase-RegisteredChainEquivalence-bytes-string-]]
==== `[.contract-item-name]#++RegisteredChainEquivalence++#++(bytes erc7930binary, string axelar)++` [.item-kind]#event#

A chain equivalence has been registered.

[.contract-item]
[[AxelarGatewayBase-UnsupportedERC7930Chain-bytes-]]
==== `[.contract-item-name]#++UnsupportedERC7930Chain++#++(bytes erc7930binary)++` [.item-kind]#error#

Error emitted when an unsupported chain is queried.

[.contract-item]
[[AxelarGatewayBase-UnsupportedAxelarChain-string-]]
==== `[.contract-item-name]#++UnsupportedAxelarChain++#++(string axelar)++` [.item-kind]#error#

[.contract-item]
[[AxelarGatewayBase-InvalidChainIdentifier-bytes-]]
==== `[.contract-item-name]#++InvalidChainIdentifier++#++(bytes erc7930binary)++` [.item-kind]#error#

[.contract-item]
[[AxelarGatewayBase-ChainEquivalenceAlreadyRegistered-bytes-string-]]
==== `[.contract-item-name]#++ChainEquivalenceAlreadyRegistered++#++(bytes erc7930binary, string axelar)++` [.item-kind]#error#

[.contract-item]
[[AxelarGatewayBase-RemoteGatewayAlreadyRegistered-bytes2-bytes-]]
==== `[.contract-item-name]#++RemoteGatewayAlreadyRegistered++#++(bytes2 chainType, bytes chainReference)++` [.item-kind]#error#

[.contract-item]
[[AxelarGatewayBase-_axelarGateway-contract-IAxelarGateway]]
==== `contract IAxelarGateway [.contract-item-name]#++_axelarGateway++#` [.item-kind]#internal#

Axelar's official gateway for the current chain.

:UnsupportedNativeTransfer: pass:normal[xref:#AxelarGatewaySource-UnsupportedNativeTransfer--[`++UnsupportedNativeTransfer++`]]
:supportsAttribute: pass:normal[xref:#AxelarGatewaySource-supportsAttribute-bytes4-[`++supportsAttribute++`]]
:sendMessage: pass:normal[xref:#AxelarGatewaySource-sendMessage-bytes-bytes-bytes---[`++sendMessage++`]]

[.contract]
[[AxelarGatewaySource]]
=== `++AxelarGatewaySource++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/crosschain/axelar/AxelarGatewaySource.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/crosschain/axelar/AxelarGatewaySource.sol";
```

Implementation of an ERC-7786 gateway source adapter for the Axelar Network.

The contract provides a way to send messages to a remote chain via the Axelar Network
using the {sendMessage} function.

[.contract-index]
.Functions
--
* `++supportsAttribute()++`
* `++sendMessage(recipient, payload, attributes)++`

[.contract-subindex-inherited]
.AxelarGatewayBase
* `++getAxelarChain(input)++`
* `++getErc7930Chain(input)++`
* `++getRemoteGateway(chain)++`
* `++getRemoteGateway(chainType, chainReference)++`
* `++registerChainEquivalence(chain, axelar)++`
* `++registerRemoteGateway(remote)++`

[.contract-subindex-inherited]
.Ownable
* `++owner()++`
* `++_checkOwner()++`
* `++renounceOwnership()++`
* `++transferOwnership(newOwner)++`
* `++_transferOwnership(newOwner)++`

[.contract-subindex-inherited]
.IERC7786GatewaySource

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.AxelarGatewayBase
* `++RegisteredRemoteGateway(remote)++`
* `++RegisteredChainEquivalence(erc7930binary, axelar)++`

[.contract-subindex-inherited]
.Ownable
* `++OwnershipTransferred(previousOwner, newOwner)++`

[.contract-subindex-inherited]
.IERC7786GatewaySource
* `++MessageSent(sendId, sender, receiver, payload, value, attributes)++`

--

[.contract-index]
.Errors
--
* `++UnsupportedNativeTransfer()++`

[.contract-subindex-inherited]
.AxelarGatewayBase
* `++UnsupportedERC7930Chain(erc7930binary)++`
* `++UnsupportedAxelarChain(axelar)++`
* `++InvalidChainIdentifier(erc7930binary)++`
* `++ChainEquivalenceAlreadyRegistered(erc7930binary, axelar)++`
* `++RemoteGatewayAlreadyRegistered(chainType, chainReference)++`

[.contract-subindex-inherited]
.Ownable
* `++OwnableUnauthorizedAccount(account)++`
* `++OwnableInvalidOwner(owner)++`

[.contract-subindex-inherited]
.IERC7786GatewaySource
* `++UnsupportedAttribute(selector)++`

--

[.contract-item]
[[AxelarGatewaySource-supportsAttribute-bytes4-]]
==== `[.contract-item-name]#++supportsAttribute++#++(bytes4) → bool++` [.item-kind]#public#

Getter to check whether an attribute is supported or not.

[.contract-item]
[[AxelarGatewaySource-sendMessage-bytes-bytes-bytes---]]
==== `[.contract-item-name]#++sendMessage++#++(bytes recipient, bytes payload, bytes[] attributes) → bytes32 sendId++` [.item-kind]#external#

Endpoint for creating a new message. If the message requires further (gateway specific) processing before
it can be sent to the destination chain, then a non-zero `outboxId` must be returned. Otherwise, the
message MUST be sent and this function must return 0.

* MUST emit a {MessageSent} event.

If any of the `attributes` is not supported, this function SHOULD revert with an {UnsupportedAttribute} error.
Other errors SHOULD revert with errors not specified in ERC-7786.

[.contract-item]
[[AxelarGatewaySource-UnsupportedNativeTransfer--]]
==== `[.contract-item-name]#++UnsupportedNativeTransfer++#++()++` [.item-kind]#error#

:InvalidOriginGateway: pass:normal[xref:#AxelarGatewayDestination-InvalidOriginGateway-string-string-[`++InvalidOriginGateway++`]]
:ReceiverExecutionFailed: pass:normal[xref:#AxelarGatewayDestination-ReceiverExecutionFailed--[`++ReceiverExecutionFailed++`]]
:_execute: pass:normal[xref:#AxelarGatewayDestination-_execute-bytes32-string-string-bytes-[`++_execute++`]]

[.contract]
[[AxelarGatewayDestination]]
=== `++AxelarGatewayDestination++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/crosschain/axelar/AxelarGatewayDestination.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/crosschain/axelar/AxelarGatewayDestination.sol";
```

Implementation of an ERC-7786 gateway destination adapter for the Axelar Network in dual mode.

The contract implements AxelarExecutable's {_execute} function to execute the message, converting Axelar's native
workflow into the standard ERC-7786.

[.contract-index]
.Functions
--
* `++_execute(commandId, axelarSourceChain, axelarSourceAddress, adapterPayload)++`

[.contract-subindex-inherited]
.AxelarExecutable
* `++execute(commandId, sourceChain, sourceAddress, payload)++`
* `++gateway()++`

[.contract-subindex-inherited]
.IAxelarExecutable

[.contract-subindex-inherited]
.AxelarGatewayBase
* `++getAxelarChain(input)++`
* `++getErc7930Chain(input)++`
* `++getRemoteGateway(chain)++`
* `++getRemoteGateway(chainType, chainReference)++`
* `++registerChainEquivalence(chain, axelar)++`
* `++registerRemoteGateway(remote)++`

[.contract-subindex-inherited]
.Ownable
* `++owner()++`
* `++_checkOwner()++`
* `++renounceOwnership()++`
* `++transferOwnership(newOwner)++`
* `++_transferOwnership(newOwner)++`

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.AxelarExecutable

[.contract-subindex-inherited]
.IAxelarExecutable

[.contract-subindex-inherited]
.AxelarGatewayBase
* `++RegisteredRemoteGateway(remote)++`
* `++RegisteredChainEquivalence(erc7930binary, axelar)++`

[.contract-subindex-inherited]
.Ownable
* `++OwnershipTransferred(previousOwner, newOwner)++`

--

[.contract-index]
.Errors
--
* `++InvalidOriginGateway(axelarSourceChain, axelarSourceAddress)++`
* `++ReceiverExecutionFailed()++`

[.contract-subindex-inherited]
.AxelarExecutable

[.contract-subindex-inherited]
.IAxelarExecutable
* `++InvalidAddress()++`
* `++NotApprovedByGateway()++`

[.contract-subindex-inherited]
.AxelarGatewayBase
* `++UnsupportedERC7930Chain(erc7930binary)++`
* `++UnsupportedAxelarChain(axelar)++`
* `++InvalidChainIdentifier(erc7930binary)++`
* `++ChainEquivalenceAlreadyRegistered(erc7930binary, axelar)++`
* `++RemoteGatewayAlreadyRegistered(chainType, chainReference)++`

[.contract-subindex-inherited]
.Ownable
* `++OwnableUnauthorizedAccount(account)++`
* `++OwnableInvalidOwner(owner)++`

--

[.contract-item]
[[AxelarGatewayDestination-_execute-bytes32-string-string-bytes-]]
==== `[.contract-item-name]#++_execute++#++(bytes32 commandId, string axelarSourceChain, string axelarSourceAddress, bytes adapterPayload)++` [.item-kind]#internal#

Execution of a cross-chain message.

In this function:

- `axelarSourceChain` is in the Axelar format. It should not be expected to be a proper ERC-7930 format
- `axelarSourceAddress` is the sender of the Axelar message. That should be the remote gateway on the chain
  which the message originates from. It is NOT the sender of the ERC-7786 crosschain message.

Proper ERC-7930 encoding of the crosschain message sender can be found in the message

[.contract-item]
[[AxelarGatewayDestination-InvalidOriginGateway-string-string-]]
==== `[.contract-item-name]#++InvalidOriginGateway++#++(string axelarSourceChain, string axelarSourceAddress)++` [.item-kind]#error#

[.contract-item]
[[AxelarGatewayDestination-ReceiverExecutionFailed--]]
==== `[.contract-item-name]#++ReceiverExecutionFailed++#++()++` [.item-kind]#error#

:constructor: pass:normal[xref:#AxelarGatewayDuplex-constructor-contract-IAxelarGateway-address-[`++constructor++`]]

[.contract]
[[AxelarGatewayDuplex]]
=== `++AxelarGatewayDuplex++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/crosschain/axelar/AxelarGatewayDuplex.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/crosschain/axelar/AxelarGatewayDuplex.sol";
```

A contract that combines the functionality of both the source and destination gateway
adapters for the Axelar Network. Allowing to either send or receive messages across chains.

[.contract-index]
.Functions
--
* `++constructor(gateway, initialOwner)++`

[.contract-subindex-inherited]
.AxelarGatewayDestination
* `++_execute(commandId, axelarSourceChain, axelarSourceAddress, adapterPayload)++`

[.contract-subindex-inherited]
.AxelarExecutable
* `++execute(commandId, sourceChain, sourceAddress, payload)++`
* `++gateway()++`

[.contract-subindex-inherited]
.IAxelarExecutable

[.contract-subindex-inherited]
.AxelarGatewaySource
* `++supportsAttribute()++`
* `++sendMessage(recipient, payload, attributes)++`

[.contract-subindex-inherited]
.AxelarGatewayBase
* `++getAxelarChain(input)++`
* `++getErc7930Chain(input)++`
* `++getRemoteGateway(chain)++`
* `++getRemoteGateway(chainType, chainReference)++`
* `++registerChainEquivalence(chain, axelar)++`
* `++registerRemoteGateway(remote)++`

[.contract-subindex-inherited]
.Ownable
* `++owner()++`
* `++_checkOwner()++`
* `++renounceOwnership()++`
* `++transferOwnership(newOwner)++`
* `++_transferOwnership(newOwner)++`

[.contract-subindex-inherited]
.IERC7786GatewaySource

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.AxelarGatewayDestination

[.contract-subindex-inherited]
.AxelarExecutable

[.contract-subindex-inherited]
.IAxelarExecutable

[.contract-subindex-inherited]
.AxelarGatewaySource

[.contract-subindex-inherited]
.AxelarGatewayBase
* `++RegisteredRemoteGateway(remote)++`
* `++RegisteredChainEquivalence(erc7930binary, axelar)++`

[.contract-subindex-inherited]
.Ownable
* `++OwnershipTransferred(previousOwner, newOwner)++`

[.contract-subindex-inherited]
.IERC7786GatewaySource
* `++MessageSent(sendId, sender, receiver, payload, value, attributes)++`

--

[.contract-index]
.Errors
--

[.contract-subindex-inherited]
.AxelarGatewayDestination
* `++InvalidOriginGateway(axelarSourceChain, axelarSourceAddress)++`
* `++ReceiverExecutionFailed()++`

[.contract-subindex-inherited]
.AxelarExecutable

[.contract-subindex-inherited]
.IAxelarExecutable
* `++InvalidAddress()++`
* `++NotApprovedByGateway()++`

[.contract-subindex-inherited]
.AxelarGatewaySource
* `++UnsupportedNativeTransfer()++`

[.contract-subindex-inherited]
.AxelarGatewayBase
* `++UnsupportedERC7930Chain(erc7930binary)++`
* `++UnsupportedAxelarChain(axelar)++`
* `++InvalidChainIdentifier(erc7930binary)++`
* `++ChainEquivalenceAlreadyRegistered(erc7930binary, axelar)++`
* `++RemoteGatewayAlreadyRegistered(chainType, chainReference)++`

[.contract-subindex-inherited]
.Ownable
* `++OwnableUnauthorizedAccount(account)++`
* `++OwnableInvalidOwner(owner)++`

[.contract-subindex-inherited]
.IERC7786GatewaySource
* `++UnsupportedAttribute(selector)++`

--

[.contract-item]
[[AxelarGatewayDuplex-constructor-contract-IAxelarGateway-address-]]
==== `[.contract-item-name]#++constructor++#++(contract IAxelarGateway gateway, address initialOwner)++` [.item-kind]#public#

Initializes the contract with the Axelar gateway and the initial owner.

