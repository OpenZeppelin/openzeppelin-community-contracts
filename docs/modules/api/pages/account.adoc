:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:AccountCore: pass:normal[xref:account.adoc#AccountCore[`AccountCore`]]
:Account: pass:normal[xref:account.adoc#Account[`Account`]]
:ERC7821: pass:normal[xref:account.adoc#ERC7821[`ERC7821`]]
:AccountCore-_signableUserOpHash: pass:normal[xref:account.adoc#AccountCore-_signableUserOpHash-struct-PackedUserOperation-bytes32-[`AccountCore._signableUserOpHash`]]
:AbstractSigner-_rawSignatureValidation: pass:normal[xref:utils.adoc#AbstractSigner-_rawSignatureValidation-bytes32-bytes-[`AbstractSigner._rawSignatureValidation`]]
:SignerECDSA: pass:normal[xref:utils.adoc#SignerECDSA[`SignerECDSA`]]
:SignerP256: pass:normal[xref:utils.adoc#SignerP256[`SignerP256`]]
:SignerRSA: pass:normal[xref:utils.adoc#SignerRSA[`SignerRSA`]]
:AccountCore: pass:normal[xref:account.adoc#AccountCore[`AccountCore`]]
:ERC7739: pass:normal[xref:utils.adoc#ERC7739[`ERC7739`]]
:ERC7821: pass:normal[xref:account.adoc#ERC7821[`ERC7821`]]
:ERC7821: pass:normal[xref:account.adoc#ERC7821[`ERC7821`]]
:SignerECDSA: pass:normal[xref:utils.adoc#SignerECDSA[`SignerECDSA`]]
:SignerP256: pass:normal[xref:utils.adoc#SignerP256[`SignerP256`]]
:SignerRSA: pass:normal[xref:utils.adoc#SignerRSA[`SignerRSA`]]
:AccountCore-_signableUserOpHash: pass:normal[xref:account.adoc#AccountCore-_signableUserOpHash-struct-PackedUserOperation-bytes32-[`AccountCore._signableUserOpHash`]]
:SignerECDSA: pass:normal[xref:utils.adoc#SignerECDSA[`SignerECDSA`]]
:SignerERC7702: pass:normal[xref:utils.adoc#SignerERC7702[`SignerERC7702`]]
= Account
[.readme-notice]
NOTE: This document is better viewed at https://docs.openzeppelin.com/community-contracts/api/account

This directory includes contracts to build accounts for ERC-4337. These include:

 * {AccountCore}: An ERC-4337 smart account implementation that includes the core logic to process user operations.
 * {Account}: An extension of `AccountCore` that implements the recommended features for ERC-4337 smart accounts.
 * {AccountSignerERC7702}: An account implementation with low-level signature validation performed by an EOA.
 * {ERC7821}: Minimal batch executor implementation contracts. Useful to enable easy batch execution for smart contracts.

== Core

:AccountUnauthorized: pass:normal[xref:#AccountCore-AccountUnauthorized-address-[`++AccountUnauthorized++`]]
:onlyEntryPointOrSelf: pass:normal[xref:#AccountCore-onlyEntryPointOrSelf--[`++onlyEntryPointOrSelf++`]]
:onlyEntryPoint: pass:normal[xref:#AccountCore-onlyEntryPoint--[`++onlyEntryPoint++`]]
:entryPoint: pass:normal[xref:#AccountCore-entryPoint--[`++entryPoint++`]]
:getNonce: pass:normal[xref:#AccountCore-getNonce--[`++getNonce++`]]
:getNonce: pass:normal[xref:#AccountCore-getNonce-uint192-[`++getNonce++`]]
:validateUserOp: pass:normal[xref:#AccountCore-validateUserOp-struct-PackedUserOperation-bytes32-uint256-[`++validateUserOp++`]]
:_validateUserOp: pass:normal[xref:#AccountCore-_validateUserOp-struct-PackedUserOperation-bytes32-[`++_validateUserOp++`]]
:_signableUserOpHash: pass:normal[xref:#AccountCore-_signableUserOpHash-struct-PackedUserOperation-bytes32-[`++_signableUserOpHash++`]]
:_payPrefund: pass:normal[xref:#AccountCore-_payPrefund-uint256-[`++_payPrefund++`]]
:_checkEntryPoint: pass:normal[xref:#AccountCore-_checkEntryPoint--[`++_checkEntryPoint++`]]
:_checkEntryPointOrSelf: pass:normal[xref:#AccountCore-_checkEntryPointOrSelf--[`++_checkEntryPointOrSelf++`]]
:receive: pass:normal[xref:#AccountCore-receive--[`++receive++`]]

[.contract]
[[AccountCore]]
=== `++AccountCore++` link:https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v0.0.1/contracts/account/AccountCore.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/contracts/account/AccountCore.sol";
```

A simple ERC4337 account implementation. This base implementation only includes the minimal logic to process
user operations.

Developers must implement the {AccountCore-_signableUserOpHash} and {AbstractSigner-_rawSignatureValidation}
functions to define the account's validation logic.

NOTE: This core account doesn't include any mechanism for performing arbitrary external calls. This is an essential
feature that all Account should have. We leave it up to the developers to implement the mechanism of their choice.
Common choices include ERC-6900, ERC-7579 and ERC-7821 (among others).

IMPORTANT: Implementing a mechanism to validate signatures is a security-sensitive operation as it may allow an
attacker to bypass the account's security measures. Check out {SignerECDSA}, {SignerP256}, or {SignerRSA} for
digital signature validation implementations.

[.contract-index]
.Modifiers
--
* `++onlyEntryPointOrSelf()++`
* `++onlyEntryPoint()++`
--

[.contract-index]
.Functions
--
* `++entryPoint()++`
* `++getNonce()++`
* `++getNonce(key)++`
* `++validateUserOp(userOp, userOpHash, missingAccountFunds)++`
* `++_validateUserOp(userOp, userOpHash)++`
* `++_signableUserOpHash(userOp, userOpHash)++`
* `++_payPrefund(missingAccountFunds)++`
* `++_checkEntryPoint()++`
* `++_checkEntryPointOrSelf()++`
* `++receive()++`

[.contract-subindex-inherited]
.IAccount

[.contract-subindex-inherited]
.AbstractSigner
* `++_rawSignatureValidation(hash, signature)++`

--

[.contract-index]
.Errors
--
* `++AccountUnauthorized(sender)++`

[.contract-subindex-inherited]
.IAccount

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[AccountCore-onlyEntryPointOrSelf--]]
==== `[.contract-item-name]#++onlyEntryPointOrSelf++#++()++` [.item-kind]#modifier#

Revert if the caller is not the entry point or the account itself.

[.contract-item]
[[AccountCore-onlyEntryPoint--]]
==== `[.contract-item-name]#++onlyEntryPoint++#++()++` [.item-kind]#modifier#

Revert if the caller is not the entry point.

[.contract-item]
[[AccountCore-entryPoint--]]
==== `[.contract-item-name]#++entryPoint++#++() → contract IEntryPoint++` [.item-kind]#public#

Canonical entry point for the account that forwards and validates user operations.

[.contract-item]
[[AccountCore-getNonce--]]
==== `[.contract-item-name]#++getNonce++#++() → uint256++` [.item-kind]#public#

Return the account nonce for the canonical sequence.

[.contract-item]
[[AccountCore-getNonce-uint192-]]
==== `[.contract-item-name]#++getNonce++#++(uint192 key) → uint256++` [.item-kind]#public#

Return the account nonce for a given sequence (key).

[.contract-item]
[[AccountCore-validateUserOp-struct-PackedUserOperation-bytes32-uint256-]]
==== `[.contract-item-name]#++validateUserOp++#++(struct PackedUserOperation userOp, bytes32 userOpHash, uint256 missingAccountFunds) → uint256++` [.item-kind]#public#

Validates a user operation.

* MUST validate the caller is a trusted EntryPoint
* MUST validate that the signature is a valid signature of the userOpHash, and SHOULD
  return SIG_VALIDATION_FAILED (and not revert) on signature mismatch. Any other error MUST revert.
* MUST pay the entryPoint (caller) at least the “missingAccountFunds” (which might
  be zero, in case the current account’s deposit is high enough)

Returns an encoded packed validation data that is composed of the following elements:

- `authorizer` (`address`): 0 for success, 1 for failure, otherwise the address of an authorizer contract
- `validUntil` (`uint48`): The UserOp is valid only up to this time. Zero for “infinite”.
- `validAfter` (`uint48`): The UserOp is valid only after this time.

[.contract-item]
[[AccountCore-_validateUserOp-struct-PackedUserOperation-bytes32-]]
==== `[.contract-item-name]#++_validateUserOp++#++(struct PackedUserOperation userOp, bytes32 userOpHash) → uint256++` [.item-kind]#internal#

Returns the validationData for a given user operation. By default, this checks the signature of the
signable hash (produced by {_signableUserOpHash}) using the abstract signer ({_rawSignatureValidation}).

NOTE: The userOpHash is assumed to be correct. Calling this function with a userOpHash that does not match the
userOp will result in undefined behavior.

[.contract-item]
[[AccountCore-_signableUserOpHash-struct-PackedUserOperation-bytes32-]]
==== `[.contract-item-name]#++_signableUserOpHash++#++(struct PackedUserOperation userOp, bytes32 userOpHash) → bytes32++` [.item-kind]#internal#

Virtual function that returns the signable hash for a user operations. Some implementation may return
`userOpHash` while other may prefer a signer-friendly value such as an EIP-712 hash describing the `userOp`
details.

[.contract-item]
[[AccountCore-_payPrefund-uint256-]]
==== `[.contract-item-name]#++_payPrefund++#++(uint256 missingAccountFunds)++` [.item-kind]#internal#

Sends the missing funds for executing the user operation to the {entrypoint}.
The `missingAccountFunds` must be defined by the entrypoint when calling {validateUserOp}.

[.contract-item]
[[AccountCore-_checkEntryPoint--]]
==== `[.contract-item-name]#++_checkEntryPoint++#++()++` [.item-kind]#internal#

Ensures the caller is the {entrypoint}.

[.contract-item]
[[AccountCore-_checkEntryPointOrSelf--]]
==== `[.contract-item-name]#++_checkEntryPointOrSelf++#++()++` [.item-kind]#internal#

Ensures the caller is the {entrypoint} or the account itself.

[.contract-item]
[[AccountCore-receive--]]
==== `[.contract-item-name]#++receive++#++()++` [.item-kind]#external#

Receive Ether.

[.contract-item]
[[AccountCore-AccountUnauthorized-address-]]
==== `[.contract-item-name]#++AccountUnauthorized++#++(address sender)++` [.item-kind]#error#

Unauthorized call to the account.

:_PACKED_USER_OPERATION: pass:normal[xref:#Account-_PACKED_USER_OPERATION-bytes32[`++_PACKED_USER_OPERATION++`]]
:_signableUserOpHash: pass:normal[xref:#Account-_signableUserOpHash-struct-PackedUserOperation-bytes32-[`++_signableUserOpHash++`]]

[.contract]
[[Account]]
=== `++Account++` link:https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v0.0.1/contracts/account/Account.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/contracts/account/Account.sol";
```

Extension of {AccountCore} with recommended feature that most account abstraction implementation will want:

* {ERC721Holder} and {ERC1155Holder} to accept ERC-712 and ERC-1155 token transfers transfers.
* {ERC7739} for ERC-1271 signature support with ERC-7739 replay protection
* {ERC7821} for performing external calls in batches.

TIP: Use {ERC7821} to enable external calls in batches.

NOTE: To use this contract, the {ERC7739-_rawSignatureValidation} function must be
implemented using a specific signature verification algorithm. See {SignerECDSA}, {SignerP256} or {SignerRSA}.

[.contract-index]
.Functions
--
* `++_signableUserOpHash(userOp, )++`

[.contract-subindex-inherited]
.ERC7739
* `++isValidSignature(hash, signature)++`

[.contract-subindex-inherited]
.IERC1271

[.contract-subindex-inherited]
.ERC1155Holder
* `++supportsInterface(interfaceId)++`
* `++onERC1155Received(, , , , )++`
* `++onERC1155BatchReceived(, , , , )++`

[.contract-subindex-inherited]
.IERC1155Receiver

[.contract-subindex-inherited]
.ERC165

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.ERC721Holder
* `++onERC721Received(, , , )++`

[.contract-subindex-inherited]
.EIP712
* `++_domainSeparatorV4()++`
* `++_hashTypedDataV4(structHash)++`
* `++eip712Domain()++`
* `++_EIP712Name()++`
* `++_EIP712Version()++`

[.contract-subindex-inherited]
.IERC5267

[.contract-subindex-inherited]
.IERC721Receiver

[.contract-subindex-inherited]
.AccountCore
* `++entryPoint()++`
* `++getNonce()++`
* `++getNonce(key)++`
* `++validateUserOp(userOp, userOpHash, missingAccountFunds)++`
* `++_validateUserOp(userOp, userOpHash)++`
* `++_payPrefund(missingAccountFunds)++`
* `++_checkEntryPoint()++`
* `++_checkEntryPointOrSelf()++`
* `++receive()++`

[.contract-subindex-inherited]
.IAccount

[.contract-subindex-inherited]
.AbstractSigner
* `++_rawSignatureValidation(hash, signature)++`

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.ERC7739

[.contract-subindex-inherited]
.IERC1271

[.contract-subindex-inherited]
.ERC1155Holder

[.contract-subindex-inherited]
.IERC1155Receiver

[.contract-subindex-inherited]
.ERC165

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.ERC721Holder

[.contract-subindex-inherited]
.EIP712

[.contract-subindex-inherited]
.IERC5267
* `++EIP712DomainChanged()++`

[.contract-subindex-inherited]
.IERC721Receiver

[.contract-subindex-inherited]
.AccountCore

[.contract-subindex-inherited]
.IAccount

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Errors
--

[.contract-subindex-inherited]
.ERC7739

[.contract-subindex-inherited]
.IERC1271

[.contract-subindex-inherited]
.ERC1155Holder

[.contract-subindex-inherited]
.IERC1155Receiver

[.contract-subindex-inherited]
.ERC165

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.ERC721Holder

[.contract-subindex-inherited]
.EIP712

[.contract-subindex-inherited]
.IERC5267

[.contract-subindex-inherited]
.IERC721Receiver

[.contract-subindex-inherited]
.AccountCore
* `++AccountUnauthorized(sender)++`

[.contract-subindex-inherited]
.IAccount

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Internal Variables
--
* `++bytes32 constant _PACKED_USER_OPERATION++`

[.contract-subindex-inherited]
.ERC7739

[.contract-subindex-inherited]
.IERC1271

[.contract-subindex-inherited]
.ERC1155Holder

[.contract-subindex-inherited]
.IERC1155Receiver

[.contract-subindex-inherited]
.ERC165

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.ERC721Holder

[.contract-subindex-inherited]
.EIP712

[.contract-subindex-inherited]
.IERC5267

[.contract-subindex-inherited]
.IERC721Receiver

[.contract-subindex-inherited]
.AccountCore

[.contract-subindex-inherited]
.IAccount

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[Account-_signableUserOpHash-struct-PackedUserOperation-bytes32-]]
==== `[.contract-item-name]#++_signableUserOpHash++#++(struct PackedUserOperation userOp, bytes32) → bytes32++` [.item-kind]#internal#

Specialization of {AccountCore-_signableUserOpHash} that returns a typehash following EIP-712 typed data
hashing for readability. This assumes the underlying signature scheme implements `signTypedData`, which will be
the case when combined with {SignerECDSA} or {SignerERC7702}.

[.contract-item]
[[Account-_PACKED_USER_OPERATION-bytes32]]
==== `bytes32 [.contract-item-name]#++_PACKED_USER_OPERATION++#` [.item-kind]#internal constant#

== Extensions

:UnsupportedExecutionMode: pass:normal[xref:#ERC7821-UnsupportedExecutionMode--[`++UnsupportedExecutionMode++`]]
:execute: pass:normal[xref:#ERC7821-execute-bytes32-bytes-[`++execute++`]]
:supportsExecutionMode: pass:normal[xref:#ERC7821-supportsExecutionMode-bytes32-[`++supportsExecutionMode++`]]
:_erc7821AuthorizedExecutor: pass:normal[xref:#ERC7821-_erc7821AuthorizedExecutor-address-bytes32-bytes-[`++_erc7821AuthorizedExecutor++`]]

[.contract]
[[ERC7821]]
=== `++ERC7821++` link:https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v0.0.1/contracts/account/extensions/ERC7821.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/contracts/account/extensions/ERC7821.sol";
```

Minimal batch executor following ERC-7821. Only supports basic mode (no optional "opData").

[.contract-index]
.Functions
--
* `++execute(mode, executionData)++`
* `++supportsExecutionMode(mode)++`
* `++_erc7821AuthorizedExecutor(caller, , )++`

[.contract-subindex-inherited]
.IERC7821

--

[.contract-index]
.Errors
--
* `++UnsupportedExecutionMode()++`

[.contract-subindex-inherited]
.IERC7821

--

[.contract-item]
[[ERC7821-execute-bytes32-bytes-]]
==== `[.contract-item-name]#++execute++#++(bytes32 mode, bytes executionData)++` [.item-kind]#public#

Executes the calls in `executionData` with no optional `opData` support.

NOTE: Access to this function is controlled by {_erc7821AuthorizedExecutor}. Changing access permissions, for
example to approve calls by the ERC-4337 entrypoint, should be implement by overriding it.

Reverts and bubbles up error if any call fails.

[.contract-item]
[[ERC7821-supportsExecutionMode-bytes32-]]
==== `[.contract-item-name]#++supportsExecutionMode++#++(bytes32 mode) → bool result++` [.item-kind]#public#

This function is provided for frontends to detect support.
Only returns true for:
- `bytes32(0x01000000000000000000...)`: does not support optional `opData`.
- `bytes32(0x01000000000078210001...)`: supports optional `opData`.

[.contract-item]
[[ERC7821-_erc7821AuthorizedExecutor-address-bytes32-bytes-]]
==== `[.contract-item-name]#++_erc7821AuthorizedExecutor++#++(address caller, bytes32, bytes) → bool++` [.item-kind]#internal#

Access control mechanism for the {execute} function.
By default, only the contract itself is allowed to execute.

Override this function to implement custom access control, for example to allow the
ERC-4337 entrypoint to execute.

```solidity
function _erc7821AuthorizedExecutor(
  address caller,
  bytes32 mode,
  bytes calldata executionData
) internal view virtual override returns (bool) {
  return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);
}
```

[.contract-item]
[[ERC7821-UnsupportedExecutionMode--]]
==== `[.contract-item-name]#++UnsupportedExecutionMode++#++()++` [.item-kind]#error#

