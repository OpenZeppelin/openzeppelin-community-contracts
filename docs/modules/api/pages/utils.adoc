:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:ERC7739: pass:normal[xref:utils.adoc#ERC7739[`ERC7739`]]
:ERC7739Utils: pass:normal[xref:utils.adoc#ERC7739Utils[`ERC7739Utils`]]
:SignerECDSA: pass:normal[xref:utils.adoc#SignerECDSA[`SignerECDSA`]]
:SignerP256: pass:normal[xref:utils.adoc#SignerP256[`SignerP256`]]
:SignerRSA: pass:normal[xref:utils.adoc#SignerRSA[`SignerRSA`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Masks: pass:normal[xref:utils.adoc#Masks[`Masks`]]
:ERC7739Utils: pass:normal[xref:utils.adoc#ERC7739Utils[`ERC7739Utils`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Account: pass:normal[xref:account.adoc#Account[`Account`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Account: pass:normal[xref:account.adoc#Account[`Account`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Account: pass:normal[xref:account.adoc#Account[`Account`]]
:AbstractSigner-_rawSignatureValidation: pass:normal[xref:utils.adoc#AbstractSigner-_rawSignatureValidation-bytes32-bytes-[`AbstractSigner._rawSignatureValidation`]]
= Utilities

[.readme-notice]
NOTE: This document is better viewed at https://docs.openzeppelin.com/community-contracts/utils

Miscellaneous contracts and libraries containing utility functions you can use to improve security, work with new data types, or safely use low-level primitives.

 * {AbstractSigner}: Abstract contract for internal signature validation in smart contracts.
 * {ERC7739}: An abstract contract to validate signatures following the rehashing scheme from `ERC7739Utils`.
 * {ERC7739Utils}: Utilities library that implements a defensive rehashing mechanism to prevent replayability of smart contract signatures based on ERC-7739.
 * {SignerECDSA}, {SignerP256}, {SignerRSA}: Implementations of an {AbstractSigner} with specific signature validation algorithms.
 * {Masks}: Library to handle `bytes32` masks.

== Cryptography

:_rawSignatureValidation: pass:normal[xref:#AbstractSigner-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[AbstractSigner]]
=== `++AbstractSigner++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/AbstractSigner.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/AbstractSigner.sol";
```

Abstract contract for signature validation.

Developers must implement {_rawSignatureValidation} and use it as the lowest-level signature validation mechanism.

[.contract-index]
.Functions
--
* `++_rawSignatureValidation(hash, signature)++`

--

[.contract-item]
[[AbstractSigner-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Signature validation algorithm.

WARNING: Implementing a signature validation algorithm is a security-sensitive operation as it involves
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries (https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA],
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] or https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA]).

:isValidSignature: pass:normal[xref:#ERC7739-isValidSignature-bytes32-bytes-[`++isValidSignature++`]]

[.contract]
[[ERC7739]]
=== `++ERC7739++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/ERC7739.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/ERC7739.sol";
```

Validates signatures wrapping the message hash in a nested EIP712 type. See {ERC7739Utils}.

Linking the signature to the EIP-712 domain separator is a security measure to prevent signature replay across different
EIP-712 domains (e.g. a single offchain owner of multiple contracts).

This contract requires implementing the {_rawSignatureValidation} function, which passes the wrapped message hash,
which may be either an typed data or a personal sign nested type.

NOTE: https://docs.openzeppelin.com/contracts/api/utils#EIP712[EIP-712] uses
https://docs.openzeppelin.com/contracts/api/utils#ShortStrings[ShortStrings] to optimize gas costs for
short strings (up to 31 characters). Consider that strings longer than that will use storage, which
may limit the ability of the signer to be used within the ERC-4337 validation phase (due to
https://eips.ethereum.org/EIPS/eip-7562#storage-rules[ERC-7562 storage access rules]).

[.contract-index]
.Functions
--
* `++isValidSignature(hash, signature)++`

[.contract-subindex-inherited]
.IERC1271

[.contract-subindex-inherited]
.EIP712
* `++_domainSeparatorV4()++`
* `++_hashTypedDataV4(structHash)++`
* `++eip712Domain()++`
* `++_EIP712Name()++`
* `++_EIP712Version()++`

[.contract-subindex-inherited]
.IERC5267

[.contract-subindex-inherited]
.AbstractSigner
* `++_rawSignatureValidation(hash, signature)++`

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.IERC1271

[.contract-subindex-inherited]
.EIP712

[.contract-subindex-inherited]
.IERC5267
* `++EIP712DomainChanged()++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[ERC7739-isValidSignature-bytes32-bytes-]]
==== `[.contract-item-name]#++isValidSignature++#++(bytes32 hash, bytes signature) → bytes4 result++` [.item-kind]#public#

Attempts validating the signature in a nested EIP-712 type.

A nested EIP-712 type might be presented in 2 different ways:

- As a nested EIP-712 typed data
- As a _personal_ signature (an EIP-712 mimic of the `eth_personalSign` for a smart contract)

:encodeTypedDataSig: pass:normal[xref:#ERC7739Utils-encodeTypedDataSig-bytes-bytes32-bytes32-string-[`++encodeTypedDataSig++`]]
:decodeTypedDataSig: pass:normal[xref:#ERC7739Utils-decodeTypedDataSig-bytes-[`++decodeTypedDataSig++`]]
:personalSignStructHash: pass:normal[xref:#ERC7739Utils-personalSignStructHash-bytes32-[`++personalSignStructHash++`]]
:typedDataSignStructHash: pass:normal[xref:#ERC7739Utils-typedDataSignStructHash-string-string-bytes32-bytes-[`++typedDataSignStructHash++`]]
:typedDataSignStructHash: pass:normal[xref:#ERC7739Utils-typedDataSignStructHash-string-bytes32-bytes-[`++typedDataSignStructHash++`]]
:typedDataSignTypehash: pass:normal[xref:#ERC7739Utils-typedDataSignTypehash-string-string-[`++typedDataSignTypehash++`]]
:decodeContentsDescr: pass:normal[xref:#ERC7739Utils-decodeContentsDescr-string-[`++decodeContentsDescr++`]]

[.contract]
[[ERC7739Utils]]
=== `++ERC7739Utils++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/ERC7739Utils.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/ERC7739Utils.sol";
```

Utilities to process https://ercs.ethereum.org/ERCS/erc-7739[ERC-7739] typed data signatures
that are specific to an EIP-712 domain.

This library provides methods to wrap, unwrap and operate over typed data signatures with a defensive
rehashing mechanism that includes the application's
https://docs.openzeppelin.com/contracts/api/utils#EIP712-_domainSeparatorV4[EIP-712]
and preserves readability of the signed content using an EIP-712 nested approach.

A smart contract domain can validate a signature for a typed data structure in two ways:

- As an application validating a typed data signature. See {typedDataSignStructHash}.
- As a smart contract validating a raw message signature. See {personalSignStructHash}.

NOTE: A provider for a smart contract wallet would need to return this signature as the
result of a call to `personal_sign` or `eth_signTypedData`, and this may be unsupported by
API clients that expect a return value of 129 bytes, or specifically the `r,s,v` parameters
of an https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA] signature, as is for
example specified for https://docs.openzeppelin.com/contracts/api/utils#EIP712[EIP-712].

[.contract-index]
.Functions
--
* `++encodeTypedDataSig(signature, appSeparator, contentsHash, contentsDescr)++`
* `++decodeTypedDataSig(encodedSignature)++`
* `++personalSignStructHash(contents)++`
* `++typedDataSignStructHash(contentsName, contentsType, contentsHash, domainBytes)++`
* `++typedDataSignStructHash(contentsDescr, contentsHash, domainBytes)++`
* `++typedDataSignTypehash(contentsName, contentsType)++`
* `++decodeContentsDescr(contentsDescr)++`

--

[.contract-item]
[[ERC7739Utils-encodeTypedDataSig-bytes-bytes32-bytes32-string-]]
==== `[.contract-item-name]#++encodeTypedDataSig++#++(bytes signature, bytes32 appSeparator, bytes32 contentsHash, string contentsDescr) → bytes++` [.item-kind]#internal#

Nest a signature for a given EIP-712 type into a nested signature for the domain of the app.

Counterpart of {decodeTypedDataSig} to extract the original signature and the nested components.

[.contract-item]
[[ERC7739Utils-decodeTypedDataSig-bytes-]]
==== `[.contract-item-name]#++decodeTypedDataSig++#++(bytes encodedSignature) → bytes signature, bytes32 appSeparator, bytes32 contentsHash, string contentsDescr++` [.item-kind]#internal#

Parses a nested signature into its components.

Constructed as follows:

`signature ‖ APP_DOMAIN_SEPARATOR ‖ contentsHash ‖ contentsDescr ‖ uint16(contentsDescr.length)`

- `signature` is the signature for the (ERC-7739) nested struct hash. This signature indirectly signs over the
  original "contents" hash (from the app) and the account's domain separator.
- `APP_DOMAIN_SEPARATOR` is the EIP-712 {EIP712-_domainSeparatorV4} of the application smart contract that is
  requesting the signature verification (though ERC-1271).
- `contentsHash` is the hash of the underlying data structure or message.
- `contentsDescr` is a descriptor of the "contents" part of the the EIP-712 type of the nested signature.

NOTE: This function returns empty if the input format is invalid instead of reverting.
data instead.

[.contract-item]
[[ERC7739Utils-personalSignStructHash-bytes32-]]
==== `[.contract-item-name]#++personalSignStructHash++#++(bytes32 contents) → bytes32++` [.item-kind]#internal#

Nests an `ERC-191` digest into a `PersonalSign` EIP-712 struct, and returns the corresponding struct hash.
This struct hash must be combined with a domain separator, using {MessageHashUtils-toTypedDataHash} before
being verified/recovered.

This is used to simulates the `personal_sign` RPC method in the context of smart contracts.

[.contract-item]
[[ERC7739Utils-typedDataSignStructHash-string-string-bytes32-bytes-]]
==== `[.contract-item-name]#++typedDataSignStructHash++#++(string contentsName, string contentsType, bytes32 contentsHash, bytes domainBytes) → bytes32 result++` [.item-kind]#internal#

Nests an `EIP-712` hash (`contents`) into a `TypedDataSign` EIP-712 struct, and returns the corresponding
struct hash. This struct hash must be combined with a domain separator, using {MessageHashUtils-toTypedDataHash}
before being verified/recovered.

[.contract-item]
[[ERC7739Utils-typedDataSignStructHash-string-bytes32-bytes-]]
==== `[.contract-item-name]#++typedDataSignStructHash++#++(string contentsDescr, bytes32 contentsHash, bytes domainBytes) → bytes32 result++` [.item-kind]#internal#

Variant of {typedDataSignStructHash-string-string-bytes32-bytes} that takes a content descriptor
and decodes the `contentsName` and `contentsType` out of it.

[.contract-item]
[[ERC7739Utils-typedDataSignTypehash-string-string-]]
==== `[.contract-item-name]#++typedDataSignTypehash++#++(string contentsName, string contentsType) → bytes32++` [.item-kind]#internal#

Compute the EIP-712 typehash of the `TypedDataSign` structure for a given type (and typename).

[.contract-item]
[[ERC7739Utils-decodeContentsDescr-string-]]
==== `[.contract-item-name]#++decodeContentsDescr++#++(string contentsDescr) → string contentsName, string contentsType++` [.item-kind]#internal#

Parse the type name out of the ERC-7739 contents type description. Supports both the implicit and explicit
modes.

Following ERC-7739 specifications, a `contentsName` is considered invalid if it's empty or it contains
any of the following bytes , )\x00

If the `contentsType` is invalid, this returns an empty string. Otherwise, the return string has non-zero
length.

:_setSigner: pass:normal[xref:#SignerECDSA-_setSigner-address-[`++_setSigner++`]]
:signer: pass:normal[xref:#SignerECDSA-signer--[`++signer++`]]
:_rawSignatureValidation: pass:normal[xref:#SignerECDSA-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerECDSA]]
=== `++SignerECDSA++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/SignerECDSA.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/SignerECDSA.sol";
```

Implementation of {AbstractSigner} using
https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA] signatures.

For {Account} usage, a {_setSigner} function is provided to set the {signer} address.
Doing so is easier for a factory, who is likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountECDSA is Account, SignerECDSA, Initializable {
    constructor() EIP712("MyAccountECDSA", "1") {}

    function initialize(address signerAddr) public initializer {
      _setSigner(signerAddr);
    }
}
```

IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++_setSigner(signerAddr)++`
* `++signer()++`
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerECDSA-_setSigner-address-]]
==== `[.contract-item-name]#++_setSigner++#++(address signerAddr)++` [.item-kind]#internal#

Sets the signer with the address of the native signer. This function should be called during construction
or through an initializer.

[.contract-item]
[[SignerECDSA-signer--]]
==== `[.contract-item-name]#++signer++#++() → address++` [.item-kind]#public#

Return the signer's address.

[.contract-item]
[[SignerECDSA-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Signature validation algorithm.

WARNING: Implementing a signature validation algorithm is a security-sensitive operation as it involves
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries (https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA],
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] or https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA]).

:SignerP256InvalidPublicKey: pass:normal[xref:#SignerP256-SignerP256InvalidPublicKey-bytes32-bytes32-[`++SignerP256InvalidPublicKey++`]]
:_setSigner: pass:normal[xref:#SignerP256-_setSigner-bytes32-bytes32-[`++_setSigner++`]]
:signer: pass:normal[xref:#SignerP256-signer--[`++signer++`]]
:_rawSignatureValidation: pass:normal[xref:#SignerP256-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerP256]]
=== `++SignerP256++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/SignerP256.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/SignerP256.sol";
```

Implementation of {AbstractSigner} using
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] signatures.

For {Account} usage, a {_setSigner} function is provided to set the {signer} public key.
Doing so is easier for a factory, who is likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountP256 is Account, SignerP256, Initializable {
    constructor() EIP712("MyAccountP256", "1") {}

    function initialize(bytes32 qx, bytes32 qy) public initializer {
      _setSigner(qx, qy);
    }
}
```

IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++_setSigner(qx, qy)++`
* `++signer()++`
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Errors
--
* `++SignerP256InvalidPublicKey(qx, qy)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerP256-_setSigner-bytes32-bytes32-]]
==== `[.contract-item-name]#++_setSigner++#++(bytes32 qx, bytes32 qy)++` [.item-kind]#internal#

Sets the signer with a P256 public key. This function should be called during construction
or through an initializer.

[.contract-item]
[[SignerP256-signer--]]
==== `[.contract-item-name]#++signer++#++() → bytes32 qx, bytes32 qy++` [.item-kind]#public#

Return the signer's P256 public key.

[.contract-item]
[[SignerP256-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Signature validation algorithm.

WARNING: Implementing a signature validation algorithm is a security-sensitive operation as it involves
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries (https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA],
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] or https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA]).

[.contract-item]
[[SignerP256-SignerP256InvalidPublicKey-bytes32-bytes32-]]
==== `[.contract-item-name]#++SignerP256InvalidPublicKey++#++(bytes32 qx, bytes32 qy)++` [.item-kind]#error#

:_setSigner: pass:normal[xref:#SignerRSA-_setSigner-bytes-bytes-[`++_setSigner++`]]
:signer: pass:normal[xref:#SignerRSA-signer--[`++signer++`]]
:_rawSignatureValidation: pass:normal[xref:#SignerRSA-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerRSA]]
=== `++SignerRSA++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/SignerRSA.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/SignerRSA.sol";
```

Implementation of {AbstractSigner} using
https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA] signatures.

For {Account} usage, a {_setSigner} function is provided to set the {signer} public key.
Doing so is easier for a factory, who is likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountRSA is Account, SignerRSA, Initializable {
    constructor() EIP712("MyAccountRSA", "1") {}

    function initialize(bytes memory e, bytes memory n) public initializer {
      _setSigner(e, n);
    }
}
```

IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++_setSigner(e, n)++`
* `++signer()++`
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerRSA-_setSigner-bytes-bytes-]]
==== `[.contract-item-name]#++_setSigner++#++(bytes e, bytes n)++` [.item-kind]#internal#

Sets the signer with a RSA public key. This function should be called during construction
or through an initializer.

[.contract-item]
[[SignerRSA-signer--]]
==== `[.contract-item-name]#++signer++#++() → bytes e, bytes n++` [.item-kind]#public#

Return the signer's RSA public key.

[.contract-item]
[[SignerRSA-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

See {AbstractSigner-_rawSignatureValidation}. Verifies a PKCSv1.5 signature by calling
https://docs.openzeppelin.com/contracts/5.x/api/utils#RSA-pkcs1Sha256-bytes-bytes-bytes-bytes-[RSA.pkcs1Sha256].

IMPORTANT: Following the RSASSA-PKCS1-V1_5-VERIFY procedure outlined in RFC8017 (section 8.2.2), the
provided `hash` is used as the `M` (message) and rehashed using SHA256 according to EMSA-PKCS1-v1_5
encoding as per section 9.2 (step 1) of the RFC.

== Libraries

:Mask: pass:normal[xref:#Masks-Mask[`++Mask++`]]
:toMask: pass:normal[xref:#Masks-toMask-uint8-[`++toMask++`]]
:toMask: pass:normal[xref:#Masks-toMask-uint8---[`++toMask++`]]
:get: pass:normal[xref:#Masks-get-Masks-Mask-uint8-[`++get++`]]
:isEmpty: pass:normal[xref:#Masks-isEmpty-Masks-Mask-[`++isEmpty++`]]
:complement: pass:normal[xref:#Masks-complement-Masks-Mask-[`++complement++`]]
:union: pass:normal[xref:#Masks-union-Masks-Mask-Masks-Mask-[`++union++`]]
:intersection: pass:normal[xref:#Masks-intersection-Masks-Mask-Masks-Mask-[`++intersection++`]]
:difference: pass:normal[xref:#Masks-difference-Masks-Mask-Masks-Mask-[`++difference++`]]
:symmetricDifference: pass:normal[xref:#Masks-symmetricDifference-Masks-Mask-Masks-Mask-[`++symmetricDifference++`]]

[.contract]
[[Masks]]
=== `++Masks++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/Masks.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/Masks.sol";
```

Library for handling bit masks

[.contract-index]
.Functions
--
* `++toMask(group)++`
* `++toMask(groups)++`
* `++get(self, group)++`
* `++isEmpty(self)++`
* `++complement(m1)++`
* `++union(m1, m2)++`
* `++intersection(m1, m2)++`
* `++difference(m1, m2)++`
* `++symmetricDifference(m1, m2)++`

--

[.contract-item]
[[Masks-toMask-uint8-]]
==== `[.contract-item-name]#++toMask++#++(uint8 group) → Masks.Mask++` [.item-kind]#internal#

Returns a new mask with the bit at `group` index set to 1.

[.contract-item]
[[Masks-toMask-uint8---]]
==== `[.contract-item-name]#++toMask++#++(uint8[] groups) → Masks.Mask++` [.item-kind]#internal#

Returns a new mask with the bits at `groups` indices set to 1.

[.contract-item]
[[Masks-get-Masks-Mask-uint8-]]
==== `[.contract-item-name]#++get++#++(Masks.Mask self, uint8 group) → bool++` [.item-kind]#internal#

Get value of the mask at `group` index

[.contract-item]
[[Masks-isEmpty-Masks-Mask-]]
==== `[.contract-item-name]#++isEmpty++#++(Masks.Mask self) → bool++` [.item-kind]#internal#

Whether the mask is `bytes32(0)`

[.contract-item]
[[Masks-complement-Masks-Mask-]]
==== `[.contract-item-name]#++complement++#++(Masks.Mask m1) → Masks.Mask++` [.item-kind]#internal#

Invert the bits of a mask

[.contract-item]
[[Masks-union-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++union++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Perform a bitwise OR operation on two masks

[.contract-item]
[[Masks-intersection-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++intersection++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Perform a bitwise AND operation on two masks

[.contract-item]
[[Masks-difference-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++difference++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Perform a bitwise difference operation on two masks (m1 - m2)

[.contract-item]
[[Masks-symmetricDifference-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++symmetricDifference++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Returns the symmetric difference (∆) of two masks, also known as disjunctive union or exclusive OR (XOR)

