:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:ERC7739Signer: pass:normal[xref:utils.adoc#ERC7739Signer[`ERC7739Signer`]]
:ERC7739Utils: pass:normal[xref:utils.adoc#ERC7739Utils[`ERC7739Utils`]]
:SignerECDSA: pass:normal[xref:utils.adoc#SignerECDSA[`SignerECDSA`]]
:SignerP256: pass:normal[xref:utils.adoc#SignerP256[`SignerP256`]]
:SignerRSA: pass:normal[xref:utils.adoc#SignerRSA[`SignerRSA`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Masks: pass:normal[xref:utils.adoc#Masks[`Masks`]]
:ERC7739Utils: pass:normal[xref:utils.adoc#ERC7739Utils[`ERC7739Utils`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Account: pass:normal[xref:account.adoc#Account[`Account`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Account: pass:normal[xref:account.adoc#Account[`Account`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Account: pass:normal[xref:account.adoc#Account[`Account`]]
= Utilities

[.readme-notice]
NOTE: This document is better viewed at https://docs.openzeppelin.com/community-contracts/utils

Miscellaneous contracts and libraries containing utility functions you can use to improve security, work with new data types, or safely use low-level primitives.

 * {AbstractSigner}: Abstract contract for internal signature validation in smart contracts.
 * {ERC7739Signer}: An abstract contract to validate signatures following the rehashing scheme from `ERC7739Utils`.
 * {ERC7739Utils}: Utilities library that implements a defensive rehashing mechanism to prevent replayability of smart contract signatures based on ERC-7739.
 * {SignerECDSA}, {SignerP256}, {SignerRSA}: Implementations of an {AbstractSigner} with specific signature validation algorithms.
 * {Masks}: Library to handle `bytes32` masks.

== Cryptography

:_rawSignatureValidation: pass:normal[xref:#AbstractSigner-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[AbstractSigner]]
=== `++AbstractSigner++` link:https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v0.0.1/contracts/utils/cryptography/AbstractSigner.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/contracts/utils/cryptography/AbstractSigner.sol";
```

Abstract contract for signature validation.

Developers must implement {_rawSignatureValidation} and use it as the lowest-level signature validation mechanism.

[.contract-index]
.Functions
--
* `++_rawSignatureValidation(hash, signature)++`

--

[.contract-item]
[[AbstractSigner-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Signature validation algorithm.

WARNING: Implementing a signature validation algorithm is a security-sensitive operation as it involves
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries (https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA],
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] or https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA]).

:isValidSignature: pass:normal[xref:#ERC7739Signer-isValidSignature-bytes32-bytes-[`++isValidSignature++`]]

[.contract]
[[ERC7739Signer]]
=== `++ERC7739Signer++` link:https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v0.0.1/contracts/utils/cryptography/draft-ERC7739Signer.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/contracts/utils/cryptography/draft-ERC7739Signer.sol";
```

Validates signatures wrapping the message hash in a nested EIP712 type. See {ERC7739Utils}.

Linking the signature to the EIP-712 domain separator is a security measure to prevent signature replay across different
EIP-712 domains (e.g. a single offchain owner of multiple contracts).

This contract requires implementing the {_rawSignatureValidation} function, which passes the wrapped message hash,
which may be either an typed data or a personal sign nested type.

NOTE: https://docs.openzeppelin.com/contracts/api/utils#EIP712[EIP-712] uses
https://docs.openzeppelin.com/contracts/api/utils#ShortStrings[ShortStrings] to optimize gas costs for
short strings (up to 31 characters). Consider that strings longer than that will use storage, which
may limit the ability of the signer to be used within the ERC-4337 validation phase (due to
https://eips.ethereum.org/EIPS/eip-7562#storage-rules[ERC-7562 storage access rules]).

[.contract-index]
.Functions
--
* `++isValidSignature(hash, signature)++`

[.contract-subindex-inherited]
.IERC1271

[.contract-subindex-inherited]
.EIP712
* `++_domainSeparatorV4()++`
* `++_hashTypedDataV4(structHash)++`
* `++eip712Domain()++`
* `++_EIP712Name()++`
* `++_EIP712Version()++`

[.contract-subindex-inherited]
.IERC5267

[.contract-subindex-inherited]
.AbstractSigner
* `++_rawSignatureValidation(hash, signature)++`

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.IERC1271

[.contract-subindex-inherited]
.EIP712

[.contract-subindex-inherited]
.IERC5267
* `++EIP712DomainChanged()++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[ERC7739Signer-isValidSignature-bytes32-bytes-]]
==== `[.contract-item-name]#++isValidSignature++#++(bytes32 hash, bytes signature) → bytes4 result++` [.item-kind]#public#

Attempts validating the signature in a nested EIP-712 type.

A nested EIP-712 type might be presented in 2 different ways:

- As a nested EIP-712 typed data
- As a _personal_ signature (an EIP-712 mimic of the `eth_personalSign` for a smart contract)

:InvalidContentsType: pass:normal[xref:#ERC7739Utils-InvalidContentsType--[`++InvalidContentsType++`]]
:encodeTypedDataSig: pass:normal[xref:#ERC7739Utils-encodeTypedDataSig-bytes-bytes32-bytes32-string-[`++encodeTypedDataSig++`]]
:decodeTypedDataSig: pass:normal[xref:#ERC7739Utils-decodeTypedDataSig-bytes-[`++decodeTypedDataSig++`]]
:personalSignStructHash: pass:normal[xref:#ERC7739Utils-personalSignStructHash-bytes32-[`++personalSignStructHash++`]]
:typedDataSignStructHash: pass:normal[xref:#ERC7739Utils-typedDataSignStructHash-string-string-bytes32-bytes-[`++typedDataSignStructHash++`]]
:typedDataSignStructHash: pass:normal[xref:#ERC7739Utils-typedDataSignStructHash-string-bytes32-bytes-[`++typedDataSignStructHash++`]]
:typedDataSignTypehash: pass:normal[xref:#ERC7739Utils-typedDataSignTypehash-string-string-[`++typedDataSignTypehash++`]]
:decodeContentsDescr: pass:normal[xref:#ERC7739Utils-decodeContentsDescr-string-[`++decodeContentsDescr++`]]

[.contract]
[[ERC7739Utils]]
=== `++ERC7739Utils++` link:https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v0.0.1/contracts/utils/cryptography/draft-ERC7739Utils.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/contracts/utils/cryptography/draft-ERC7739Utils.sol";
```

Utilities to process https://ercs.ethereum.org/ERCS/erc-7739[ERC-7739] typed data signatures
that are specific to an EIP-712 domain.

This library provides methods to wrap, unwrap and operate over typed data signatures with a defensive
rehashing mechanism that includes the application's
https://docs.openzeppelin.com/contracts/api/utils#EIP712-_domainSeparatorV4[EIP-712]
and preserves readability of the signed content using an EIP-712 nested approach.

A smart contract domain can validate a signature for a typed data structure in two ways:

- As an application validating a typed data signature. See {typedDataSignStructHash}.
- As a smart contract validating a raw message signature. See {personalSignStructHash}.

NOTE: A provider for a smart contract wallet would need to return this signature as the
result of a call to `personal_sign` or `eth_signTypedData`, and this may be unsupported by
API clients that expect a return value of 129 bytes, or specifically the `r,s,v` parameters
of an https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA] signature, as is for
example specified for https://docs.openzeppelin.com/contracts/api/utils#EIP712[EIP-712].

[.contract-index]
.Functions
--
* `++encodeTypedDataSig(signature, appSeparator, contentsHash, contentsDescr)++`
* `++decodeTypedDataSig(encodedSignature)++`
* `++personalSignStructHash(contents)++`
* `++typedDataSignStructHash(contentsTypeName, contentsType, contentsHash, domainBytes)++`
* `++typedDataSignStructHash(contentsDescr, contentsHash, domainBytes)++`
* `++typedDataSignTypehash(contentsTypeName, contentsType)++`
* `++decodeContentsDescr(contentsDescr)++`

--

[.contract-index]
.Errors
--
* `++InvalidContentsType()++`

--

[.contract-item]
[[ERC7739Utils-encodeTypedDataSig-bytes-bytes32-bytes32-string-]]
==== `[.contract-item-name]#++encodeTypedDataSig++#++(bytes signature, bytes32 appSeparator, bytes32 contentsHash, string contentsDescr) → bytes++` [.item-kind]#internal#

Nest a signature for a given EIP-712 type into a nested signature for the domain of the app.

Counterpart of {decodeTypedDataSig} to extract the original signature and the nested components.

[.contract-item]
[[ERC7739Utils-decodeTypedDataSig-bytes-]]
==== `[.contract-item-name]#++decodeTypedDataSig++#++(bytes encodedSignature) → bytes signature, bytes32 appSeparator, bytes32 contentsHash, string contentsDescr++` [.item-kind]#internal#

Parses a nested signature into its components.

Constructed as follows:

`signature ‖ DOMAIN_SEPARATOR ‖ contentsHash ‖ contentsDescr ‖ uint16(contentsDescr.length)`

- `signature` is the original signature for the nested struct hash that includes the "contents" hash
- `DOMAIN_SEPARATOR` is the EIP-712 {EIP712-_domainSeparatorV4} of the smart contract verifying the signature
- `contentsHash` is the hash of the underlying data structure or message
- `contentsDescr` is a descriptor of the "contents" part of the the EIP-712 type of the nested signature

[.contract-item]
[[ERC7739Utils-personalSignStructHash-bytes32-]]
==== `[.contract-item-name]#++personalSignStructHash++#++(bytes32 contents) → bytes32++` [.item-kind]#internal#

Nests an `ERC-191` digest into a `PersonalSign` EIP-712 struct, and return the corresponding struct hash.
This struct hash must be combined with a domain separator, using {MessageHashUtils-toTypedDataHash} before
being verified/recovered.

This is used to simulates the `personal_sign` RPC method in the context of smart contracts.

[.contract-item]
[[ERC7739Utils-typedDataSignStructHash-string-string-bytes32-bytes-]]
==== `[.contract-item-name]#++typedDataSignStructHash++#++(string contentsTypeName, string contentsType, bytes32 contentsHash, bytes domainBytes) → bytes32 result++` [.item-kind]#internal#

Nests an `EIP-712` hash (`contents`) into a `TypedDataSign` EIP-712 struct, and return the corresponding
struct hash. This struct hash must be combined with a domain separator, using {MessageHashUtils-toTypedDataHash}
before being verified/recovered.

[.contract-item]
[[ERC7739Utils-typedDataSignStructHash-string-bytes32-bytes-]]
==== `[.contract-item-name]#++typedDataSignStructHash++#++(string contentsDescr, bytes32 contentsHash, bytes domainBytes) → bytes32 result++` [.item-kind]#internal#

Variant of {typedDataSignStructHash-string-string-bytes32-string-bytes} that takes a content descriptor
and decodes the `contentsTypeName` and `contentsType` out of it.

[.contract-item]
[[ERC7739Utils-typedDataSignTypehash-string-string-]]
==== `[.contract-item-name]#++typedDataSignTypehash++#++(string contentsTypeName, string contentsType) → bytes32++` [.item-kind]#internal#

Compute the EIP-712 typehash of the `TypedDataSign` structure for a given type (and typename).

[.contract-item]
[[ERC7739Utils-decodeContentsDescr-string-]]
==== `[.contract-item-name]#++decodeContentsDescr++#++(string contentsDescr) → string contentsTypeName, string contentsType++` [.item-kind]#internal#

Parse the type name out of the ERC-7739 contents type description. Supports both the implicit and explicit
modes.

Following ERC-7739 specifications, a `contentsTypeName` is considered invalid if it's empty or it contains
any of the following bytes , )\x00

If the `contentsType` is invalid, this returns an empty string. Otherwise, the return string has non-zero
length.

[.contract-item]
[[ERC7739Utils-InvalidContentsType--]]
==== `[.contract-item-name]#++InvalidContentsType++#++()++` [.item-kind]#error#

Error when the contents type is invalid. See {tryValidateContentsType}.

:SignerECDSAUninitializedSigner: pass:normal[xref:#SignerECDSA-SignerECDSAUninitializedSigner-address-[`++SignerECDSAUninitializedSigner++`]]
:_initializeSigner: pass:normal[xref:#SignerECDSA-_initializeSigner-address-[`++_initializeSigner++`]]
:signer: pass:normal[xref:#SignerECDSA-signer--[`++signer++`]]
:_rawSignatureValidation: pass:normal[xref:#SignerECDSA-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerECDSA]]
=== `++SignerECDSA++` link:https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v0.0.1/contracts/utils/cryptography/SignerECDSA.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/contracts/utils/cryptography/SignerECDSA.sol";
```

Implementation of {AbstractSigner} using
https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA] signatures.

For {Account} usage, an {_initializeSigner} function is provided to set the {signer} address.
Doing so it's easier for a factory, whose likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountECDSA is Account, SignerECDSA {
    constructor() EIP712("MyAccountECDSA", "1") {}

    function initializeSigner(address signerAddr) public virtual initializer {
      // Will revert if the signer is already initialized
      _initializeSigner(signerAddr);
    }
}
```

IMPORTANT: Avoiding to call {_initializeSigner} either during construction (if used standalone)
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++_initializeSigner(signerAddr)++`
* `++signer()++`
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Errors
--
* `++SignerECDSAUninitializedSigner(signer)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerECDSA-_initializeSigner-address-]]
==== `[.contract-item-name]#++_initializeSigner++#++(address signerAddr)++` [.item-kind]#internal#

Initializes the signer with the address of the native signer. This function can be called only once.

[.contract-item]
[[SignerECDSA-signer--]]
==== `[.contract-item-name]#++signer++#++() → address++` [.item-kind]#public#

Return the signer's address.

[.contract-item]
[[SignerECDSA-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Signature validation algorithm.

WARNING: Implementing a signature validation algorithm is a security-sensitive operation as it involves
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries (https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA],
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] or https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA]).

[.contract-item]
[[SignerECDSA-SignerECDSAUninitializedSigner-address-]]
==== `[.contract-item-name]#++SignerECDSAUninitializedSigner++#++(address signer)++` [.item-kind]#error#

The {signer} is already initialized.

:SignerP256UninitializedSigner: pass:normal[xref:#SignerP256-SignerP256UninitializedSigner-bytes32-bytes32-[`++SignerP256UninitializedSigner++`]]
:_initializeSigner: pass:normal[xref:#SignerP256-_initializeSigner-bytes32-bytes32-[`++_initializeSigner++`]]
:signer: pass:normal[xref:#SignerP256-signer--[`++signer++`]]
:_rawSignatureValidation: pass:normal[xref:#SignerP256-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerP256]]
=== `++SignerP256++` link:https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v0.0.1/contracts/utils/cryptography/SignerP256.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/contracts/utils/cryptography/SignerP256.sol";
```

Implementation of {AbstractSigner} using
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] signatures.

For {Account} usage, an {_initializeSigner} function is provided to set the {signer} public key.
Doing so it's easier for a factory, whose likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountP256 is Account, SignerP256 {
    constructor() EIP712("MyAccountP256", "1") {}

    function initializeSigner(bytes32 qx, bytes32 qy) public virtual initializer {
      // Will revert if the signer is already initialized
      _initializeSigner(qx, qy);
    }
}
```

IMPORTANT: Avoiding to call {_initializeSigner} either during construction (if used standalone)
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++_initializeSigner(qx, qy)++`
* `++signer()++`
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Errors
--
* `++SignerP256UninitializedSigner(qx, qy)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerP256-_initializeSigner-bytes32-bytes32-]]
==== `[.contract-item-name]#++_initializeSigner++#++(bytes32 qx, bytes32 qy)++` [.item-kind]#internal#

Initializes the signer with the P256 public key. This function can be called only once.

[.contract-item]
[[SignerP256-signer--]]
==== `[.contract-item-name]#++signer++#++() → bytes32 qx, bytes32 qy++` [.item-kind]#public#

Return the signer's P256 public key.

[.contract-item]
[[SignerP256-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Signature validation algorithm.

WARNING: Implementing a signature validation algorithm is a security-sensitive operation as it involves
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries (https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA],
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] or https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA]).

[.contract-item]
[[SignerP256-SignerP256UninitializedSigner-bytes32-bytes32-]]
==== `[.contract-item-name]#++SignerP256UninitializedSigner++#++(bytes32 qx, bytes32 qy)++` [.item-kind]#error#

The {signer} is already initialized.

:SignerRSAUninitializedSigner: pass:normal[xref:#SignerRSA-SignerRSAUninitializedSigner-bytes-bytes-[`++SignerRSAUninitializedSigner++`]]
:_initializeSigner: pass:normal[xref:#SignerRSA-_initializeSigner-bytes-bytes-[`++_initializeSigner++`]]
:signer: pass:normal[xref:#SignerRSA-signer--[`++signer++`]]
:_rawSignatureValidation: pass:normal[xref:#SignerRSA-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerRSA]]
=== `++SignerRSA++` link:https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v0.0.1/contracts/utils/cryptography/SignerRSA.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/contracts/utils/cryptography/SignerRSA.sol";
```

Implementation of {AbstractSigner} using
https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA] signatures.

For {Account} usage, an {_initializeSigner} function is provided to set the {signer} public key.
Doing so it's easier for a factory, whose likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountRSA is Account, SignerRSA {
    constructor() EIP712("MyAccountRSA", "1") {}

    function initializeSigner(bytes memory e, bytes memory n) external {
      // Will revert if the signer is already initialized
      _initializeSigner(e, n);
    }
}
```

IMPORTANT: Avoiding to call {_initializeSigner} either during construction (if used standalone)
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++_initializeSigner(e, n)++`
* `++signer()++`
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Errors
--
* `++SignerRSAUninitializedSigner(e, n)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerRSA-_initializeSigner-bytes-bytes-]]
==== `[.contract-item-name]#++_initializeSigner++#++(bytes e, bytes n)++` [.item-kind]#internal#

Initializes the signer with the RSA public key. This function can be called only once.

[.contract-item]
[[SignerRSA-signer--]]
==== `[.contract-item-name]#++signer++#++() → bytes e, bytes n++` [.item-kind]#public#

Return the signer's RSA public key.

[.contract-item]
[[SignerRSA-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Signature validation algorithm.

WARNING: Implementing a signature validation algorithm is a security-sensitive operation as it involves
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries (https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA],
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] or https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA]).

[.contract-item]
[[SignerRSA-SignerRSAUninitializedSigner-bytes-bytes-]]
==== `[.contract-item-name]#++SignerRSAUninitializedSigner++#++(bytes e, bytes n)++` [.item-kind]#error#

The {signer} is already initialized.

== Libraries

:Mask: pass:normal[xref:#Masks-Mask[`++Mask++`]]
:toMask: pass:normal[xref:#Masks-toMask-uint8-[`++toMask++`]]
:toMask: pass:normal[xref:#Masks-toMask-uint8---[`++toMask++`]]
:get: pass:normal[xref:#Masks-get-Masks-Mask-uint8-[`++get++`]]
:isEmpty: pass:normal[xref:#Masks-isEmpty-Masks-Mask-[`++isEmpty++`]]
:complement: pass:normal[xref:#Masks-complement-Masks-Mask-[`++complement++`]]
:union: pass:normal[xref:#Masks-union-Masks-Mask-Masks-Mask-[`++union++`]]
:intersection: pass:normal[xref:#Masks-intersection-Masks-Mask-Masks-Mask-[`++intersection++`]]
:difference: pass:normal[xref:#Masks-difference-Masks-Mask-Masks-Mask-[`++difference++`]]
:symmetric_difference: pass:normal[xref:#Masks-symmetric_difference-Masks-Mask-Masks-Mask-[`++symmetric_difference++`]]

[.contract]
[[Masks]]
=== `++Masks++` link:https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v0.0.1/contracts/utils/Masks.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/contracts/utils/Masks.sol";
```

Library for handling bit masks

[.contract-index]
.Functions
--
* `++toMask(group)++`
* `++toMask(groups)++`
* `++get(self, group)++`
* `++isEmpty(self)++`
* `++complement(m1)++`
* `++union(m1, m2)++`
* `++intersection(m1, m2)++`
* `++difference(m1, m2)++`
* `++symmetric_difference(m1, m2)++`

--

[.contract-item]
[[Masks-toMask-uint8-]]
==== `[.contract-item-name]#++toMask++#++(uint8 group) → Masks.Mask++` [.item-kind]#internal#

Returns a new mask with the bit at `group` index set to 1.

[.contract-item]
[[Masks-toMask-uint8---]]
==== `[.contract-item-name]#++toMask++#++(uint8[] groups) → Masks.Mask++` [.item-kind]#internal#

Returns a new mask with the bits at `groups` indices set to 1.

[.contract-item]
[[Masks-get-Masks-Mask-uint8-]]
==== `[.contract-item-name]#++get++#++(Masks.Mask self, uint8 group) → bool++` [.item-kind]#internal#

Get value of the mask at `group` index

[.contract-item]
[[Masks-isEmpty-Masks-Mask-]]
==== `[.contract-item-name]#++isEmpty++#++(Masks.Mask self) → bool++` [.item-kind]#internal#

Whether the mask is `bytes32(0)`

[.contract-item]
[[Masks-complement-Masks-Mask-]]
==== `[.contract-item-name]#++complement++#++(Masks.Mask m1) → Masks.Mask++` [.item-kind]#internal#

Invert the bits of a mask

[.contract-item]
[[Masks-union-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++union++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Perform a bitwise OR operation on two masks

[.contract-item]
[[Masks-intersection-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++intersection++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Perform a bitwise AND operation on two masks

[.contract-item]
[[Masks-difference-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++difference++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Perform a bitwise difference operation on two masks (m1 - m2)

[.contract-item]
[[Masks-symmetric_difference-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++symmetric_difference++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Returns the symmetric difference (∆) of two masks, also known as disjunctive union or exclusive OR (XOR)

