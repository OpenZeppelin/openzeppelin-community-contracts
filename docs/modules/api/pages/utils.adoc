:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:ERC7739: pass:normal[xref:utils.adoc#ERC7739[`ERC7739`]]
:ERC7739Utils: pass:normal[xref:utils.adoc#ERC7739Utils[`ERC7739Utils`]]
:ERC7913Utils: pass:normal[xref:utils.adoc#ERC7913Utils[`ERC7913Utils`]]
:SignerECDSA: pass:normal[xref:utils.adoc#SignerECDSA[`SignerECDSA`]]
:SignerP256: pass:normal[xref:utils.adoc#SignerP256[`SignerP256`]]
:SignerRSA: pass:normal[xref:utils.adoc#SignerRSA[`SignerRSA`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:SignerERC7913: pass:normal[xref:utils.adoc#SignerERC7913[`SignerERC7913`]]
:MultiSignerERC7913: pass:normal[xref:utils.adoc#MultiSignerERC7913[`MultiSignerERC7913`]]
:MultiSignerERC7913Weighted: pass:normal[xref:utils.adoc#MultiSignerERC7913Weighted[`MultiSignerERC7913Weighted`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:ERC7913SignatureVerifierP256: pass:normal[xref:utils.adoc#ERC7913SignatureVerifierP256[`ERC7913SignatureVerifierP256`]]
:ERC7913SignatureVerifierRSA: pass:normal[xref:utils.adoc#ERC7913SignatureVerifierRSA[`ERC7913SignatureVerifierRSA`]]
:SignerECDSA: pass:normal[xref:utils.adoc#SignerECDSA[`SignerECDSA`]]
:SignerP256: pass:normal[xref:utils.adoc#SignerP256[`SignerP256`]]
:SignerRSA: pass:normal[xref:utils.adoc#SignerRSA[`SignerRSA`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:SignerZKEmail: pass:normal[xref:utils.adoc#SignerZKEmail[`SignerZKEmail`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:ZKEmailUtils: pass:normal[xref:utils.adoc#ZKEmailUtils[`ZKEmailUtils`]]
:EnumerableSetExtended: pass:normal[xref:utils.adoc#EnumerableSetExtended[`EnumerableSetExtended`]]
:EnumerableMapExtended: pass:normal[xref:utils.adoc#EnumerableMapExtended[`EnumerableMapExtended`]]
:Masks: pass:normal[xref:utils.adoc#Masks[`Masks`]]
:ERC7739Utils: pass:normal[xref:utils.adoc#ERC7739Utils[`ERC7739Utils`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Account: pass:normal[xref:account.adoc#Account[`Account`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Account: pass:normal[xref:account.adoc#Account[`Account`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:MultiSignerERC7913: pass:normal[xref:utils.adoc#MultiSignerERC7913[`MultiSignerERC7913`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Account: pass:normal[xref:account.adoc#Account[`Account`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:Account: pass:normal[xref:account.adoc#Account[`Account`]]
:AbstractSigner-_rawSignatureValidation: pass:normal[xref:utils.adoc#AbstractSigner-_rawSignatureValidation-bytes32-bytes-[`AbstractSigner._rawSignatureValidation`]]
:AbstractSigner: pass:normal[xref:utils.adoc#AbstractSigner[`AbstractSigner`]]
:AbstractSigner-_rawSignatureValidation: pass:normal[xref:utils.adoc#AbstractSigner-_rawSignatureValidation-bytes32-bytes-[`AbstractSigner._rawSignatureValidation`]]
= Utilities

[.readme-notice]
NOTE: This document is better viewed at https://docs.openzeppelin.com/community-contracts/utils

Miscellaneous contracts and libraries containing utility functions you can use to improve security, work with new data types, or safely use low-level primitives.

 * {AbstractSigner}: Abstract contract for internal signature validation in smart contracts.
 * {ERC7739}: An abstract contract to validate signatures following the rehashing scheme from `ERC7739Utils`.
 * {ERC7739Utils}: Utilities library that implements a defensive rehashing mechanism to prevent replayability of smart contract signatures based on ERC-7739.
 * {ERC7913Utils}: utilities library that implements ERC-7913 signature verification with fallback to ERC-1271 and ECDSA.
 * {SignerECDSA}, {SignerP256}, {SignerRSA}: Implementations of an {AbstractSigner} with specific signature validation algorithms.
 * {SignerERC7913}, {MultiSignerERC7913}, {MultiSignerERC7913Weighted}: Implementations of {AbstractSigner} that validate signatures based on ERC-7913. Including a simple and weighted multisignature scheme.
 * {ERC7913SignatureVerifierP256}, {ERC7913SignatureVerifierRSA}: Ready to use ERC-7913 signature verifiers for P256 and RSA keys
 * {SignerECDSA}, {SignerP256}, {SignerRSA}: Implementations of an {AbstractSigner} with specific signature validation algorithms.
 * {SignerZKEmail}: Implementation of an {AbstractSigner} that enables email-based authentication through zero-knowledge proofs.
 * {ZKEmailUtils}: Library for ZKEmail signature validation utilities, enabling email-based authentication through zero-knowledge proofs.
 * {EnumerableSetExtended} and {EnumerableMapExtended}: Extensions of the `EnumerableSet` and `EnumerableMap` libraries with more types, including non-value types.
 * {Masks}: Library to handle `bytes32` masks.

== Cryptography

:isValidSignature: pass:normal[xref:#ERC7739-isValidSignature-bytes32-bytes-[`++isValidSignature++`]]

[.contract]
[[ERC7739]]
=== `++ERC7739++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/ERC7739.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/ERC7739.sol";
```

Validates signatures wrapping the message hash in a nested EIP712 type. See {ERC7739Utils}.

Linking the signature to the EIP-712 domain separator is a security measure to prevent signature replay across different
EIP-712 domains (e.g. a single offchain owner of multiple contracts).

This contract requires implementing the {_rawSignatureValidation} function, which passes the wrapped message hash,
which may be either an typed data or a personal sign nested type.

NOTE: https://docs.openzeppelin.com/contracts/api/utils#EIP712[EIP-712] uses
https://docs.openzeppelin.com/contracts/api/utils#ShortStrings[ShortStrings] to optimize gas costs for
short strings (up to 31 characters). Consider that strings longer than that will use storage, which
may limit the ability of the signer to be used within the ERC-4337 validation phase (due to
https://eips.ethereum.org/EIPS/eip-7562#storage-rules[ERC-7562 storage access rules]).

[.contract-index]
.Functions
--
* `++isValidSignature(hash, signature)++`

[.contract-subindex-inherited]
.IERC1271

[.contract-subindex-inherited]
.EIP712
* `++_domainSeparatorV4()++`
* `++_hashTypedDataV4(structHash)++`
* `++eip712Domain()++`
* `++_EIP712Name()++`
* `++_EIP712Version()++`

[.contract-subindex-inherited]
.IERC5267

[.contract-subindex-inherited]
.AbstractSigner
* `++_rawSignatureValidation(hash, signature)++`

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.IERC1271

[.contract-subindex-inherited]
.EIP712

[.contract-subindex-inherited]
.IERC5267
* `++EIP712DomainChanged()++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[ERC7739-isValidSignature-bytes32-bytes-]]
==== `[.contract-item-name]#++isValidSignature++#++(bytes32 hash, bytes signature) → bytes4 result++` [.item-kind]#public#

Attempts validating the signature in a nested EIP-712 type.

A nested EIP-712 type might be presented in 2 different ways:

- As a nested EIP-712 typed data
- As a _personal_ signature (an EIP-712 mimic of the `eth_personalSign` for a smart contract)

:encodeTypedDataSig: pass:normal[xref:#ERC7739Utils-encodeTypedDataSig-bytes-bytes32-bytes32-string-[`++encodeTypedDataSig++`]]
:decodeTypedDataSig: pass:normal[xref:#ERC7739Utils-decodeTypedDataSig-bytes-[`++decodeTypedDataSig++`]]
:personalSignStructHash: pass:normal[xref:#ERC7739Utils-personalSignStructHash-bytes32-[`++personalSignStructHash++`]]
:typedDataSignStructHash: pass:normal[xref:#ERC7739Utils-typedDataSignStructHash-string-string-bytes32-bytes-[`++typedDataSignStructHash++`]]
:typedDataSignStructHash: pass:normal[xref:#ERC7739Utils-typedDataSignStructHash-string-bytes32-bytes-[`++typedDataSignStructHash++`]]
:typedDataSignTypehash: pass:normal[xref:#ERC7739Utils-typedDataSignTypehash-string-string-[`++typedDataSignTypehash++`]]
:decodeContentsDescr: pass:normal[xref:#ERC7739Utils-decodeContentsDescr-string-[`++decodeContentsDescr++`]]

[.contract]
[[ERC7739Utils]]
=== `++ERC7739Utils++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/ERC7739Utils.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/ERC7739Utils.sol";
```

Utilities to process https://ercs.ethereum.org/ERCS/erc-7739[ERC-7739] typed data signatures
that are specific to an EIP-712 domain.

This library provides methods to wrap, unwrap and operate over typed data signatures with a defensive
rehashing mechanism that includes the application's
https://docs.openzeppelin.com/contracts/api/utils#EIP712-_domainSeparatorV4[EIP-712]
and preserves readability of the signed content using an EIP-712 nested approach.

A smart contract domain can validate a signature for a typed data structure in two ways:

- As an application validating a typed data signature. See {typedDataSignStructHash}.
- As a smart contract validating a raw message signature. See {personalSignStructHash}.

NOTE: A provider for a smart contract wallet would need to return this signature as the
result of a call to `personal_sign` or `eth_signTypedData`, and this may be unsupported by
API clients that expect a return value of 129 bytes, or specifically the `r,s,v` parameters
of an https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA] signature, as is for
example specified for https://docs.openzeppelin.com/contracts/api/utils#EIP712[EIP-712].

[.contract-index]
.Functions
--
* `++encodeTypedDataSig(signature, appSeparator, contentsHash, contentsDescr)++`
* `++decodeTypedDataSig(encodedSignature)++`
* `++personalSignStructHash(contents)++`
* `++typedDataSignStructHash(contentsName, contentsType, contentsHash, domainBytes)++`
* `++typedDataSignStructHash(contentsDescr, contentsHash, domainBytes)++`
* `++typedDataSignTypehash(contentsName, contentsType)++`
* `++decodeContentsDescr(contentsDescr)++`

--

[.contract-item]
[[ERC7739Utils-encodeTypedDataSig-bytes-bytes32-bytes32-string-]]
==== `[.contract-item-name]#++encodeTypedDataSig++#++(bytes signature, bytes32 appSeparator, bytes32 contentsHash, string contentsDescr) → bytes++` [.item-kind]#internal#

Nest a signature for a given EIP-712 type into a nested signature for the domain of the app.

Counterpart of {decodeTypedDataSig} to extract the original signature and the nested components.

[.contract-item]
[[ERC7739Utils-decodeTypedDataSig-bytes-]]
==== `[.contract-item-name]#++decodeTypedDataSig++#++(bytes encodedSignature) → bytes signature, bytes32 appSeparator, bytes32 contentsHash, string contentsDescr++` [.item-kind]#internal#

Parses a nested signature into its components.

Constructed as follows:

`signature ‖ APP_DOMAIN_SEPARATOR ‖ contentsHash ‖ contentsDescr ‖ uint16(contentsDescr.length)`

- `signature` is the signature for the (ERC-7739) nested struct hash. This signature indirectly signs over the
  original "contents" hash (from the app) and the account's domain separator.
- `APP_DOMAIN_SEPARATOR` is the EIP-712 {EIP712-_domainSeparatorV4} of the application smart contract that is
  requesting the signature verification (though ERC-1271).
- `contentsHash` is the hash of the underlying data structure or message.
- `contentsDescr` is a descriptor of the "contents" part of the the EIP-712 type of the nested signature.

NOTE: This function returns empty if the input format is invalid instead of reverting.
data instead.

[.contract-item]
[[ERC7739Utils-personalSignStructHash-bytes32-]]
==== `[.contract-item-name]#++personalSignStructHash++#++(bytes32 contents) → bytes32++` [.item-kind]#internal#

Nests an `ERC-191` digest into a `PersonalSign` EIP-712 struct, and returns the corresponding struct hash.
This struct hash must be combined with a domain separator, using {MessageHashUtils-toTypedDataHash} before
being verified/recovered.

This is used to simulates the `personal_sign` RPC method in the context of smart contracts.

[.contract-item]
[[ERC7739Utils-typedDataSignStructHash-string-string-bytes32-bytes-]]
==== `[.contract-item-name]#++typedDataSignStructHash++#++(string contentsName, string contentsType, bytes32 contentsHash, bytes domainBytes) → bytes32 result++` [.item-kind]#internal#

Nests an `EIP-712` hash (`contents`) into a `TypedDataSign` EIP-712 struct, and returns the corresponding
struct hash. This struct hash must be combined with a domain separator, using {MessageHashUtils-toTypedDataHash}
before being verified/recovered.

[.contract-item]
[[ERC7739Utils-typedDataSignStructHash-string-bytes32-bytes-]]
==== `[.contract-item-name]#++typedDataSignStructHash++#++(string contentsDescr, bytes32 contentsHash, bytes domainBytes) → bytes32 result++` [.item-kind]#internal#

Variant of {typedDataSignStructHash-string-string-bytes32-bytes} that takes a content descriptor
and decodes the `contentsName` and `contentsType` out of it.

[.contract-item]
[[ERC7739Utils-typedDataSignTypehash-string-string-]]
==== `[.contract-item-name]#++typedDataSignTypehash++#++(string contentsName, string contentsType) → bytes32++` [.item-kind]#internal#

Compute the EIP-712 typehash of the `TypedDataSign` structure for a given type (and typename).

[.contract-item]
[[ERC7739Utils-decodeContentsDescr-string-]]
==== `[.contract-item-name]#++decodeContentsDescr++#++(string contentsDescr) → string contentsName, string contentsType++` [.item-kind]#internal#

Parse the type name out of the ERC-7739 contents type description. Supports both the implicit and explicit
modes.

Following ERC-7739 specifications, a `contentsName` is considered invalid if it's empty or it contains
any of the following bytes , )\x00

If the `contentsType` is invalid, this returns an empty string. Otherwise, the return string has non-zero
length.

:EmailProofError: pass:normal[xref:#ZKEmailUtils-EmailProofError[`++EmailProofError++`]]
:Case: pass:normal[xref:#ZKEmailUtils-Case[`++Case++`]]
:isValidZKEmail: pass:normal[xref:#ZKEmailUtils-isValidZKEmail-struct-EmailAuthMsg-contract-IDKIMRegistry-contract-IVerifier-[`++isValidZKEmail++`]]
:isValidZKEmail: pass:normal[xref:#ZKEmailUtils-isValidZKEmail-struct-EmailAuthMsg-contract-IDKIMRegistry-contract-IVerifier-string---[`++isValidZKEmail++`]]
:isValidZKEmail: pass:normal[xref:#ZKEmailUtils-isValidZKEmail-struct-EmailAuthMsg-contract-IDKIMRegistry-contract-IVerifier-string---enum-ZKEmailUtils-Case-[`++isValidZKEmail++`]]

[.contract]
[[ZKEmailUtils]]
=== `++ZKEmailUtils++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/ZKEmailUtils.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/ZKEmailUtils.sol";
```

Library for https://docs.zk.email[ZKEmail] signature validation utilities.

ZKEmail is a protocol that enables email-based authentication and authorization for smart contracts
using zero-knowledge proofs. It allows users to prove ownership of an email address without revealing
the email content or private keys.

The validation process involves several key components:

* A https://docs.zk.email/architecture/dkim-verification[DKIMRegistry] (DomainKeys Identified Mail) verification
mechanism to ensure the email was sent from a valid domain. Defined by an `IDKIMRegistry` interface.
* A https://docs.zk.email/email-tx-builder/architecture/command-templates[command template] validation
mechanism to ensure the email command matches the expected format and parameters.
* A https://docs.zk.email/architecture/zk-proofs#how-zk-email-uses-zero-knowledge-proofs[zero-knowledge proof] verification
mechanism to ensure the email was actually sent and received without revealing its contents. Defined by an `IVerifier` interface.

[.contract-index]
.Functions
--
* `++isValidZKEmail(emailAuthMsg, dkimregistry, verifier)++`
* `++isValidZKEmail(emailAuthMsg, dkimregistry, verifier, template)++`
* `++isValidZKEmail(emailAuthMsg, dkimregistry, verifier, template, stringCase)++`

--

[.contract-item]
[[ZKEmailUtils-isValidZKEmail-struct-EmailAuthMsg-contract-IDKIMRegistry-contract-IVerifier-]]
==== `[.contract-item-name]#++isValidZKEmail++#++(struct EmailAuthMsg emailAuthMsg, contract IDKIMRegistry dkimregistry, contract IVerifier verifier) → enum ZKEmailUtils.EmailProofError++` [.item-kind]#internal#

Variant of {isValidZKEmail} that validates the `["signHash", "{uint}"]` command template.

[.contract-item]
[[ZKEmailUtils-isValidZKEmail-struct-EmailAuthMsg-contract-IDKIMRegistry-contract-IVerifier-string---]]
==== `[.contract-item-name]#++isValidZKEmail++#++(struct EmailAuthMsg emailAuthMsg, contract IDKIMRegistry dkimregistry, contract IVerifier verifier, string[] template) → enum ZKEmailUtils.EmailProofError++` [.item-kind]#internal#

Validates a ZKEmail authentication message.

This function takes an email authentication message, a DKIM registry contract, and a verifier contract
as inputs. It performs several validation checks and returns a tuple containing a boolean success flag
and an {EmailProofError} if validation failed. Returns {EmailProofError.NoError} if all validations pass,
or false with a specific {EmailProofError} indicating which validation check failed.

NOTE: Attempts to validate the command for all possible string {Case} values.

[.contract-item]
[[ZKEmailUtils-isValidZKEmail-struct-EmailAuthMsg-contract-IDKIMRegistry-contract-IVerifier-string---enum-ZKEmailUtils-Case-]]
==== `[.contract-item-name]#++isValidZKEmail++#++(struct EmailAuthMsg emailAuthMsg, contract IDKIMRegistry dkimregistry, contract IVerifier verifier, string[] template, enum ZKEmailUtils.Case stringCase) → enum ZKEmailUtils.EmailProofError++` [.item-kind]#internal#

Variant of {isValidZKEmail} that validates a template with a specific string {Case}.

Useful for templates with Ethereum address matchers (i.e. `{ethAddr}`), which are case-sensitive (e.g., `["someCommand", "{address}"]`).

=== Abstract Signers

:_rawSignatureValidation: pass:normal[xref:#AbstractSigner-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[AbstractSigner]]
=== `++AbstractSigner++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/AbstractSigner.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/AbstractSigner.sol";
```

Abstract contract for signature validation.

Developers must implement {_rawSignatureValidation} and use it as the lowest-level signature validation mechanism.

[.contract-index]
.Functions
--
* `++_rawSignatureValidation(hash, signature)++`

--

[.contract-item]
[[AbstractSigner-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Signature validation algorithm.

WARNING: Implementing a signature validation algorithm is a security-sensitive operation as it involves
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries (https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA],
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] or https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA]).

:_setSigner: pass:normal[xref:#SignerECDSA-_setSigner-address-[`++_setSigner++`]]
:signer: pass:normal[xref:#SignerECDSA-signer--[`++signer++`]]
:_rawSignatureValidation: pass:normal[xref:#SignerECDSA-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerECDSA]]
=== `++SignerECDSA++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/SignerECDSA.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/SignerECDSA.sol";
```

Implementation of {AbstractSigner} using
https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA] signatures.

For {Account} usage, a {_setSigner} function is provided to set the {signer} address.
Doing so is easier for a factory, who is likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountECDSA is Account, SignerECDSA, Initializable {
    function initialize(address signerAddr) public initializer {
      _setSigner(signerAddr);
    }
}
```

IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++_setSigner(signerAddr)++`
* `++signer()++`
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerECDSA-_setSigner-address-]]
==== `[.contract-item-name]#++_setSigner++#++(address signerAddr)++` [.item-kind]#internal#

Sets the signer with the address of the native signer. This function should be called during construction
or through an initializer.

[.contract-item]
[[SignerECDSA-signer--]]
==== `[.contract-item-name]#++signer++#++() → address++` [.item-kind]#public#

Return the signer's address.

[.contract-item]
[[SignerECDSA-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Signature validation algorithm.

WARNING: Implementing a signature validation algorithm is a security-sensitive operation as it involves
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries (https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA],
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] or https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA]).

:_setSigner: pass:normal[xref:#SignerERC7913-_setSigner-bytes-[`++_setSigner++`]]
:signer: pass:normal[xref:#SignerERC7913-signer--[`++signer++`]]
:_rawSignatureValidation: pass:normal[xref:#SignerERC7913-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerERC7913]]
=== `++SignerERC7913++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/SignerERC7913.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/SignerERC7913.sol";
```

Implementation of {AbstractSigner} using
https://eips.ethereum.org/EIPS/eip-7913[ERC-7913] signature verification.

For {Account} usage, a {_setSigner} function is provided to set the ERC-7913 formatted {signer}.
Doing so is easier for a factory, who is likely to use initializable clones of this contract.

The signer is a `bytes` object that concatenates a verifier address and a key: `verifier || key`.

Example of usage:

```solidity
contract MyAccountERC7913 is Account, SignerERC7913, Initializable {
    function initialize(bytes memory signer_) public initializer {
      _setSigner(signer_);
    }
}
```

IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++_setSigner(signer_)++`
* `++signer()++`
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerERC7913-_setSigner-bytes-]]
==== `[.contract-item-name]#++_setSigner++#++(bytes signer_)++` [.item-kind]#internal#

Sets the signer (i.e. `verifier || key`) with an ERC-7913 formatted signer.

[.contract-item]
[[SignerERC7913-signer--]]
==== `[.contract-item-name]#++signer++#++() → bytes++` [.item-kind]#public#

Return the ERC-7913 signer (i.e. `verifier || key`).

[.contract-item]
[[SignerERC7913-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Verifies a signature using {ERC7913Utils.isValidSignatureNow} with {signer}, `hash` and `signature`.

:ERC7913SignersAdded: pass:normal[xref:#MultiSignerERC7913-ERC7913SignersAdded-bytes---[`++ERC7913SignersAdded++`]]
:ERC7913SignersRemoved: pass:normal[xref:#MultiSignerERC7913-ERC7913SignersRemoved-bytes---[`++ERC7913SignersRemoved++`]]
:ERC7913ThresholdSet: pass:normal[xref:#MultiSignerERC7913-ERC7913ThresholdSet-uint256-[`++ERC7913ThresholdSet++`]]
:MultiSignerERC7913AlreadyExists: pass:normal[xref:#MultiSignerERC7913-MultiSignerERC7913AlreadyExists-bytes-[`++MultiSignerERC7913AlreadyExists++`]]
:MultiSignerERC7913NonexistentSigner: pass:normal[xref:#MultiSignerERC7913-MultiSignerERC7913NonexistentSigner-bytes-[`++MultiSignerERC7913NonexistentSigner++`]]
:MultiSignerERC7913InvalidSigner: pass:normal[xref:#MultiSignerERC7913-MultiSignerERC7913InvalidSigner-bytes-[`++MultiSignerERC7913InvalidSigner++`]]
:MultiSignerERC7913UnreachableThreshold: pass:normal[xref:#MultiSignerERC7913-MultiSignerERC7913UnreachableThreshold-uint256-uint256-[`++MultiSignerERC7913UnreachableThreshold++`]]
:signerId: pass:normal[xref:#MultiSignerERC7913-signerId-bytes-[`++signerId++`]]
:signers: pass:normal[xref:#MultiSignerERC7913-signers--[`++signers++`]]
:isSigner: pass:normal[xref:#MultiSignerERC7913-isSigner-bytes-[`++isSigner++`]]
:threshold: pass:normal[xref:#MultiSignerERC7913-threshold--[`++threshold++`]]
:_signers: pass:normal[xref:#MultiSignerERC7913-_signers--[`++_signers++`]]
:_addSigners: pass:normal[xref:#MultiSignerERC7913-_addSigners-bytes---[`++_addSigners++`]]
:_removeSigners: pass:normal[xref:#MultiSignerERC7913-_removeSigners-bytes---[`++_removeSigners++`]]
:_setThreshold: pass:normal[xref:#MultiSignerERC7913-_setThreshold-uint256-[`++_setThreshold++`]]
:_validateReachableThreshold: pass:normal[xref:#MultiSignerERC7913-_validateReachableThreshold--[`++_validateReachableThreshold++`]]
:_rawSignatureValidation: pass:normal[xref:#MultiSignerERC7913-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]
:_validateNSignatures: pass:normal[xref:#MultiSignerERC7913-_validateNSignatures-bytes32-bytes---bytes---[`++_validateNSignatures++`]]
:_validateThreshold: pass:normal[xref:#MultiSignerERC7913-_validateThreshold-bytes---[`++_validateThreshold++`]]

[.contract]
[[MultiSignerERC7913]]
=== `++MultiSignerERC7913++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/MultiSignerERC7913.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/MultiSignerERC7913.sol";
```

Implementation of {AbstractSigner} using multiple ERC-7913 signers with a threshold-based
signature verification system.

This contract allows managing a set of authorized signers and requires a minimum number of
signatures (threshold) to approve operations. It uses ERC-7913 formatted signers, which
concatenate a verifier address and a key: `verifier || key`.

Example of usage:

```solidity
contract MyMultiSignerAccount is Account, MultiSignerERC7913, Initializable {
    constructor() EIP712("MyMultiSignerAccount", "1") {}

    function initialize(bytes[] memory signers, uint256 threshold) public initializer {
        _addSigners(signers);
        _setThreshold(threshold);
    }

    function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {
        _addSigners(signers);
    }

    function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {
        _removeSigners(signers);
    }

    function setThreshold(uint256 threshold) public onlyEntryPointOrSelf {
        _setThreshold(threshold);
    }
}
```

IMPORTANT: Failing to properly initialize the signers and threshold either during construction
(if used standalone) or during initialization (if used as a clone) may leave the contract
either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++signerId(signer)++`
* `++signers()++`
* `++isSigner(signer)++`
* `++threshold()++`
* `++_signers()++`
* `++_addSigners(newSigners)++`
* `++_removeSigners(oldSigners)++`
* `++_setThreshold(newThreshold)++`
* `++_validateReachableThreshold()++`
* `++_rawSignatureValidation(hash, signature)++`
* `++_validateNSignatures(hash, signingSigners, signatures)++`
* `++_validateThreshold(validatingSigners)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Events
--
* `++ERC7913SignersAdded(signers)++`
* `++ERC7913SignersRemoved(signers)++`
* `++ERC7913ThresholdSet(threshold)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Errors
--
* `++MultiSignerERC7913AlreadyExists(signer)++`
* `++MultiSignerERC7913NonexistentSigner(signer)++`
* `++MultiSignerERC7913InvalidSigner(signer)++`
* `++MultiSignerERC7913UnreachableThreshold(signers, threshold)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[MultiSignerERC7913-signerId-bytes-]]
==== `[.contract-item-name]#++signerId++#++(bytes signer) → bytes32++` [.item-kind]#public#

Returns the internal id of the `signer`.

[.contract-item]
[[MultiSignerERC7913-signers--]]
==== `[.contract-item-name]#++signers++#++() → bytes[]++` [.item-kind]#public#

Returns the set of authorized signers. Prefer {_signers} for internal use.

WARNING: This operation copies the entire signers set to memory, which can be expensive. This is designed
for view accessors queried without gas fees. Using it in state-changing functions may become uncallable
if the signers set grows too large.

[.contract-item]
[[MultiSignerERC7913-isSigner-bytes-]]
==== `[.contract-item-name]#++isSigner++#++(bytes signer) → bool++` [.item-kind]#public#

Returns whether the `signer` is an authorized signer.

[.contract-item]
[[MultiSignerERC7913-threshold--]]
==== `[.contract-item-name]#++threshold++#++() → uint256++` [.item-kind]#public#

Returns the minimum number of signers required to approve a multisignature operation.

[.contract-item]
[[MultiSignerERC7913-_signers--]]
==== `[.contract-item-name]#++_signers++#++() → struct EnumerableSetExtended.BytesSet++` [.item-kind]#internal#

Returns the set of authorized signers.

[.contract-item]
[[MultiSignerERC7913-_addSigners-bytes---]]
==== `[.contract-item-name]#++_addSigners++#++(bytes[] newSigners)++` [.item-kind]#internal#

Adds the `newSigners` to those allowed to sign on behalf of this contract. Internal version without access control.

[.contract-item]
[[MultiSignerERC7913-_removeSigners-bytes---]]
==== `[.contract-item-name]#++_removeSigners++#++(bytes[] oldSigners)++` [.item-kind]#internal#

Removes the `oldSigners` from the authorized signers. Internal version without access control.

[.contract-item]
[[MultiSignerERC7913-_setThreshold-uint256-]]
==== `[.contract-item-name]#++_setThreshold++#++(uint256 newThreshold)++` [.item-kind]#internal#

Sets the signatures `threshold` required to approve a multisignature operation. Internal version without access control.

[.contract-item]
[[MultiSignerERC7913-_validateReachableThreshold--]]
==== `[.contract-item-name]#++_validateReachableThreshold++#++()++` [.item-kind]#internal#

Validates the current threshold is reachable.

[.contract-item]
[[MultiSignerERC7913-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Decodes, validates the signature and checks the signers are authorized.
See {_validateNSignatures} and {_validateThreshold} for more details.

Example of signature encoding:

```solidity
// Encode signers (verifier || key)
bytes memory signer1 = abi.encodePacked(verifier1, key1);
bytes memory signer2 = abi.encodePacked(verifier2, key2);

// Order signers by their id
if (keccak256(signer1) > keccak256(signer2)) {
    (signer1, signer2) = (signer2, signer1);
    (signature1, signature2) = (signature2, signature1);
}

// Assign ordered signers and signatures
bytes[] memory signers = new bytes[](2);
bytes[] memory signatures = new bytes[](2);
signers[0] = signer1;
signatures[0] = signature1;
signers[1] = signer2;
signatures[1] = signature2;

// Encode the multi signature
bytes memory signature = abi.encode(signers, signatures);
```

[.contract-item]
[[MultiSignerERC7913-_validateNSignatures-bytes32-bytes---bytes---]]
==== `[.contract-item-name]#++_validateNSignatures++#++(bytes32 hash, bytes[] signingSigners, bytes[] signatures) → bool valid++` [.item-kind]#internal#

Validates the signatures using the signers and their corresponding signatures.
Returns whether whether the signers are authorized and the signatures are valid for the given hash.

IMPORTANT: For simplicity, this contract assumes that the signers are ordered by their {signerId} to
avoid duplication when iterating through the signers (i.e. `signerId(signer1) < signerId(signer2)`).
The function will return false if the signers are not ordered.

Requirements:

- The `signers` and `signatures` arrays must be of the same length.

[.contract-item]
[[MultiSignerERC7913-_validateThreshold-bytes---]]
==== `[.contract-item-name]#++_validateThreshold++#++(bytes[] validatingSigners) → bool++` [.item-kind]#internal#

Validates that the number of signers meets the {threshold} requirement.
Assumes the signers were already validated. See {_validateNSignatures} for more details.

[.contract-item]
[[MultiSignerERC7913-ERC7913SignersAdded-bytes---]]
==== `[.contract-item-name]#++ERC7913SignersAdded++#++(bytes[] indexed signers)++` [.item-kind]#event#

Emitted when signers are added.

[.contract-item]
[[MultiSignerERC7913-ERC7913SignersRemoved-bytes---]]
==== `[.contract-item-name]#++ERC7913SignersRemoved++#++(bytes[] indexed signers)++` [.item-kind]#event#

Emitted when signers are removed.

[.contract-item]
[[MultiSignerERC7913-ERC7913ThresholdSet-uint256-]]
==== `[.contract-item-name]#++ERC7913ThresholdSet++#++(uint256 threshold)++` [.item-kind]#event#

Emitted when the threshold is updated.

[.contract-item]
[[MultiSignerERC7913-MultiSignerERC7913AlreadyExists-bytes-]]
==== `[.contract-item-name]#++MultiSignerERC7913AlreadyExists++#++(bytes signer)++` [.item-kind]#error#

The `signer` already exists.

[.contract-item]
[[MultiSignerERC7913-MultiSignerERC7913NonexistentSigner-bytes-]]
==== `[.contract-item-name]#++MultiSignerERC7913NonexistentSigner++#++(bytes signer)++` [.item-kind]#error#

The `signer` does not exist.

[.contract-item]
[[MultiSignerERC7913-MultiSignerERC7913InvalidSigner-bytes-]]
==== `[.contract-item-name]#++MultiSignerERC7913InvalidSigner++#++(bytes signer)++` [.item-kind]#error#

The `signer` is less than 20 bytes long.

[.contract-item]
[[MultiSignerERC7913-MultiSignerERC7913UnreachableThreshold-uint256-uint256-]]
==== `[.contract-item-name]#++MultiSignerERC7913UnreachableThreshold++#++(uint256 signers, uint256 threshold)++` [.item-kind]#error#

The `threshold` is unreachable given the number of `signers`.

:ERC7913SignerWeightChanged: pass:normal[xref:#MultiSignerERC7913Weighted-ERC7913SignerWeightChanged-bytes-uint256-[`++ERC7913SignerWeightChanged++`]]
:MultiSignerERC7913WeightedInvalidWeight: pass:normal[xref:#MultiSignerERC7913Weighted-MultiSignerERC7913WeightedInvalidWeight-bytes-uint256-[`++MultiSignerERC7913WeightedInvalidWeight++`]]
:MultiSignerERC7913WeightedMismatchedLength: pass:normal[xref:#MultiSignerERC7913Weighted-MultiSignerERC7913WeightedMismatchedLength--[`++MultiSignerERC7913WeightedMismatchedLength++`]]
:signerWeight: pass:normal[xref:#MultiSignerERC7913Weighted-signerWeight-bytes-[`++signerWeight++`]]
:totalWeight: pass:normal[xref:#MultiSignerERC7913Weighted-totalWeight--[`++totalWeight++`]]
:_signerWeight: pass:normal[xref:#MultiSignerERC7913Weighted-_signerWeight-bytes-[`++_signerWeight++`]]
:_setSignerWeights: pass:normal[xref:#MultiSignerERC7913Weighted-_setSignerWeights-bytes---uint256---[`++_setSignerWeights++`]]
:_addSigners: pass:normal[xref:#MultiSignerERC7913Weighted-_addSigners-bytes---[`++_addSigners++`]]
:_removeSigners: pass:normal[xref:#MultiSignerERC7913Weighted-_removeSigners-bytes---[`++_removeSigners++`]]
:_validateReachableThreshold: pass:normal[xref:#MultiSignerERC7913Weighted-_validateReachableThreshold--[`++_validateReachableThreshold++`]]
:_validateThreshold: pass:normal[xref:#MultiSignerERC7913Weighted-_validateThreshold-bytes---[`++_validateThreshold++`]]
:_weightSigners: pass:normal[xref:#MultiSignerERC7913Weighted-_weightSigners-bytes---[`++_weightSigners++`]]

[.contract]
[[MultiSignerERC7913Weighted]]
=== `++MultiSignerERC7913Weighted++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/MultiSignerERC7913Weighted.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/MultiSignerERC7913Weighted.sol";
```

Extension of {MultiSignerERC7913} that supports weighted signatures.

This contract allows assigning different weights to each signer, enabling more
flexible governance schemes. For example, some signers could have higher weight
than others, allowing for weighted voting or prioritized authorization.

Example of usage:

```solidity
contract MyWeightedMultiSignerAccount is Account, MultiSignerERC7913Weighted, Initializable {
    constructor() EIP712("MyWeightedMultiSignerAccount", "1") {}

    function initialize(bytes[] memory signers, uint256[] memory weights, uint256 threshold) public initializer {
        _addSigners(signers);
        _setSignerWeights(signers, weights);
        _setThreshold(threshold);
    }

    function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {
        _addSigners(signers);
    }

    function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {
        _removeSigners(signers);
    }

    function setThreshold(uint256 threshold) public onlyEntryPointOrSelf {
        _setThreshold(threshold);
    }

    function setSignerWeights(bytes[] memory signers, uint256[] memory weights) public onlyEntryPointOrSelf {
        _setSignerWeights(signers, weights);
    }
}
```

IMPORTANT: When setting a threshold value, ensure it matches the scale used for signer weights.
For example, if signers have weights like 1, 2, or 3, then a threshold of 4 would require at
least two signers (e.g., one with weight 1 and one with weight 3). See {signerWeight}.

[.contract-index]
.Functions
--
* `++signerWeight(signer)++`
* `++totalWeight()++`
* `++_signerWeight(signer)++`
* `++_setSignerWeights(signers, newWeights)++`
* `++_addSigners(newSigners)++`
* `++_removeSigners(oldSigners)++`
* `++_validateReachableThreshold()++`
* `++_validateThreshold(signers)++`
* `++_weightSigners(signers)++`

[.contract-subindex-inherited]
.MultiSignerERC7913
* `++signerId(signer)++`
* `++signers()++`
* `++isSigner(signer)++`
* `++threshold()++`
* `++_signers()++`
* `++_setThreshold(newThreshold)++`
* `++_rawSignatureValidation(hash, signature)++`
* `++_validateNSignatures(hash, signingSigners, signatures)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Events
--
* `++ERC7913SignerWeightChanged(signer, weight)++`

[.contract-subindex-inherited]
.MultiSignerERC7913
* `++ERC7913SignersAdded(signers)++`
* `++ERC7913SignersRemoved(signers)++`
* `++ERC7913ThresholdSet(threshold)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Errors
--
* `++MultiSignerERC7913WeightedInvalidWeight(signer, weight)++`
* `++MultiSignerERC7913WeightedMismatchedLength()++`

[.contract-subindex-inherited]
.MultiSignerERC7913
* `++MultiSignerERC7913AlreadyExists(signer)++`
* `++MultiSignerERC7913NonexistentSigner(signer)++`
* `++MultiSignerERC7913InvalidSigner(signer)++`
* `++MultiSignerERC7913UnreachableThreshold(signers, threshold)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[MultiSignerERC7913Weighted-signerWeight-bytes-]]
==== `[.contract-item-name]#++signerWeight++#++(bytes signer) → uint256++` [.item-kind]#public#

Gets the weight of a signer. Returns 0 if the signer is not authorized.

[.contract-item]
[[MultiSignerERC7913Weighted-totalWeight--]]
==== `[.contract-item-name]#++totalWeight++#++() → uint256++` [.item-kind]#public#

Gets the total weight of all signers.

[.contract-item]
[[MultiSignerERC7913Weighted-_signerWeight-bytes-]]
==== `[.contract-item-name]#++_signerWeight++#++(bytes signer) → uint256++` [.item-kind]#internal#

Gets the weight of the current signer. Returns 1 if not explicitly set.

NOTE: This internal function doesn't check if the signer is authorized.

[.contract-item]
[[MultiSignerERC7913Weighted-_setSignerWeights-bytes---uint256---]]
==== `[.contract-item-name]#++_setSignerWeights++#++(bytes[] signers, uint256[] newWeights)++` [.item-kind]#internal#

Sets weights for multiple signers at once. Internal version without access control.

Requirements:

- `signers` and `weights` arrays must have the same length. Reverts with {MultiSignerERC7913WeightedMismatchedLength} on mismatch.
- Each signer must exist in the set of authorized signers. Reverts with {MultiSignerERC7913NonexistentSigner} if not.
- Each weight must be greater than 0. Reverts with {MultiSignerERC7913WeightedInvalidWeight} if not.

[.contract-item]
[[MultiSignerERC7913Weighted-_addSigners-bytes---]]
==== `[.contract-item-name]#++_addSigners++#++(bytes[] newSigners)++` [.item-kind]#internal#

Adds the `newSigners` to those allowed to sign on behalf of this contract. Internal version without access control.

[.contract-item]
[[MultiSignerERC7913Weighted-_removeSigners-bytes---]]
==== `[.contract-item-name]#++_removeSigners++#++(bytes[] oldSigners)++` [.item-kind]#internal#

Removes the `oldSigners` from the authorized signers. Internal version without access control.

[.contract-item]
[[MultiSignerERC7913Weighted-_validateReachableThreshold--]]
==== `[.contract-item-name]#++_validateReachableThreshold++#++()++` [.item-kind]#internal#

Sets the threshold for the multisignature operation. Internal version without access control.

NOTE: This function intentionally does not call `super._validateReachableThreshold` because the base implementation
assumes each signer has a weight of 1, which is a subset of this weighted implementation. Consider that multiple
implementations of this function may exist in the contract, so important side effects may be missed
depending on the linearization order.

[.contract-item]
[[MultiSignerERC7913Weighted-_validateThreshold-bytes---]]
==== `[.contract-item-name]#++_validateThreshold++#++(bytes[] signers) → bool++` [.item-kind]#internal#

Overrides the threshold validation to use signer weights.

NOTE: This function intentionally does not call `super. _validateThreshold` because the base implementation
assumes each signer has a weight of 1, which is a subset of this weighted implementation. Consider that multiple
implementations of this function may exist in the contract, so important side effects may be missed
depending on the linearization order.

[.contract-item]
[[MultiSignerERC7913Weighted-_weightSigners-bytes---]]
==== `[.contract-item-name]#++_weightSigners++#++(bytes[] signers) → uint256++` [.item-kind]#internal#

Calculates the total weight of a set of signers. For all signers weight use {totalWeight}.

[.contract-item]
[[MultiSignerERC7913Weighted-ERC7913SignerWeightChanged-bytes-uint256-]]
==== `[.contract-item-name]#++ERC7913SignerWeightChanged++#++(bytes indexed signer, uint256 weight)++` [.item-kind]#event#

Emitted when a signer's weight is changed.

[.contract-item]
[[MultiSignerERC7913Weighted-MultiSignerERC7913WeightedInvalidWeight-bytes-uint256-]]
==== `[.contract-item-name]#++MultiSignerERC7913WeightedInvalidWeight++#++(bytes signer, uint256 weight)++` [.item-kind]#error#

Thrown when a signer's weight is invalid.

[.contract-item]
[[MultiSignerERC7913Weighted-MultiSignerERC7913WeightedMismatchedLength--]]
==== `[.contract-item-name]#++MultiSignerERC7913WeightedMismatchedLength++#++()++` [.item-kind]#error#

Thrown when the threshold is unreachable.

:SignerP256InvalidPublicKey: pass:normal[xref:#SignerP256-SignerP256InvalidPublicKey-bytes32-bytes32-[`++SignerP256InvalidPublicKey++`]]
:_setSigner: pass:normal[xref:#SignerP256-_setSigner-bytes32-bytes32-[`++_setSigner++`]]
:signer: pass:normal[xref:#SignerP256-signer--[`++signer++`]]
:_rawSignatureValidation: pass:normal[xref:#SignerP256-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerP256]]
=== `++SignerP256++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/SignerP256.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/SignerP256.sol";
```

Implementation of {AbstractSigner} using
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] signatures.

For {Account} usage, a {_setSigner} function is provided to set the {signer} public key.
Doing so is easier for a factory, who is likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountP256 is Account, SignerP256, Initializable {
    function initialize(bytes32 qx, bytes32 qy) public initializer {
      _setSigner(qx, qy);
    }
}
```

IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++_setSigner(qx, qy)++`
* `++signer()++`
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Errors
--
* `++SignerP256InvalidPublicKey(qx, qy)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerP256-_setSigner-bytes32-bytes32-]]
==== `[.contract-item-name]#++_setSigner++#++(bytes32 qx, bytes32 qy)++` [.item-kind]#internal#

Sets the signer with a P256 public key. This function should be called during construction
or through an initializer.

[.contract-item]
[[SignerP256-signer--]]
==== `[.contract-item-name]#++signer++#++() → bytes32 qx, bytes32 qy++` [.item-kind]#public#

Return the signer's P256 public key.

[.contract-item]
[[SignerP256-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Signature validation algorithm.

WARNING: Implementing a signature validation algorithm is a security-sensitive operation as it involves
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries (https://docs.openzeppelin.com/contracts/api/utils#ECDSA[ECDSA],
https://docs.openzeppelin.com/contracts/api/utils#P256[P256] or https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA]).

[.contract-item]
[[SignerP256-SignerP256InvalidPublicKey-bytes32-bytes32-]]
==== `[.contract-item-name]#++SignerP256InvalidPublicKey++#++(bytes32 qx, bytes32 qy)++` [.item-kind]#error#

:_rawSignatureValidation: pass:normal[xref:#SignerERC7702-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerERC7702]]
=== `++SignerERC7702++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/SignerERC7702.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/SignerERC7702.sol";
```

Implementation of {AbstractSigner} for implementation for an EOA. Useful for ERC-7702 accounts.

[.contract-index]
.Functions
--
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerERC7702-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Validates the signature using the EOA's address (i.e. `address(this)`).

:_setSigner: pass:normal[xref:#SignerRSA-_setSigner-bytes-bytes-[`++_setSigner++`]]
:signer: pass:normal[xref:#SignerRSA-signer--[`++signer++`]]
:_rawSignatureValidation: pass:normal[xref:#SignerRSA-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerRSA]]
=== `++SignerRSA++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/SignerRSA.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/SignerRSA.sol";
```

Implementation of {AbstractSigner} using
https://docs.openzeppelin.com/contracts/api/utils#RSA[RSA] signatures.

For {Account} usage, a {_setSigner} function is provided to set the {signer} public key.
Doing so is easier for a factory, who is likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountRSA is Account, SignerRSA, Initializable {
    function initialize(bytes memory e, bytes memory n) public initializer {
      _setSigner(e, n);
    }
}
```

IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++_setSigner(e, n)++`
* `++signer()++`
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerRSA-_setSigner-bytes-bytes-]]
==== `[.contract-item-name]#++_setSigner++#++(bytes e, bytes n)++` [.item-kind]#internal#

Sets the signer with a RSA public key. This function should be called during construction
or through an initializer.

[.contract-item]
[[SignerRSA-signer--]]
==== `[.contract-item-name]#++signer++#++() → bytes e, bytes n++` [.item-kind]#public#

Return the signer's RSA public key.

[.contract-item]
[[SignerRSA-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

See {AbstractSigner-_rawSignatureValidation}. Verifies a PKCSv1.5 signature by calling
https://docs.openzeppelin.com/contracts/5.x/api/utils#RSA-pkcs1Sha256-bytes-bytes-bytes-bytes-[RSA.pkcs1Sha256].

IMPORTANT: Following the RSASSA-PKCS1-V1_5-VERIFY procedure outlined in RFC8017 (section 8.2.2), the
provided `hash` is used as the `M` (message) and rehashed using SHA256 according to EMSA-PKCS1-v1_5
encoding as per section 9.2 (step 1) of the RFC.

:InvalidEmailProof: pass:normal[xref:#SignerZKEmail-InvalidEmailProof-enum-ZKEmailUtils-EmailProofError-[`++InvalidEmailProof++`]]
:accountSalt: pass:normal[xref:#SignerZKEmail-accountSalt--[`++accountSalt++`]]
:DKIMRegistry: pass:normal[xref:#SignerZKEmail-DKIMRegistry--[`++DKIMRegistry++`]]
:verifier: pass:normal[xref:#SignerZKEmail-verifier--[`++verifier++`]]
:templateId: pass:normal[xref:#SignerZKEmail-templateId--[`++templateId++`]]
:_setAccountSalt: pass:normal[xref:#SignerZKEmail-_setAccountSalt-bytes32-[`++_setAccountSalt++`]]
:_setDKIMRegistry: pass:normal[xref:#SignerZKEmail-_setDKIMRegistry-contract-IDKIMRegistry-[`++_setDKIMRegistry++`]]
:_setVerifier: pass:normal[xref:#SignerZKEmail-_setVerifier-contract-IVerifier-[`++_setVerifier++`]]
:_setTemplateId: pass:normal[xref:#SignerZKEmail-_setTemplateId-uint256-[`++_setTemplateId++`]]
:_rawSignatureValidation: pass:normal[xref:#SignerZKEmail-_rawSignatureValidation-bytes32-bytes-[`++_rawSignatureValidation++`]]

[.contract]
[[SignerZKEmail]]
=== `++SignerZKEmail++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/SignerZKEmail.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/SignerZKEmail.sol";
```

Implementation of {AbstractSigner} using https://docs.zk.email[ZKEmail] signatures.

ZKEmail enables secure authentication and authorization through email messages, leveraging
DKIM signatures from a {DKIMRegistry} and zero-knowledge proofs enabled by a {verifier}
contract that ensures email authenticity without revealing sensitive information. The DKIM
registry is trusted to correctly update DKIM keys, but users can override this behaviour and
set their own keys. This contract implements the core functionality for validating email-based
signatures in smart contracts.

Developers must set the following components during contract initialization:

* {accountSalt} - A unique identifier derived from the user's email address and account code.
* {DKIMRegistry} - An instance of the DKIM registry contract for domain verification.
* {verifier} - An instance of the Verifier contract for zero-knowledge proof validation.
* {templateId} - The template ID of the sign hash command, defining the expected format.

Example of usage:

```solidity
contract MyAccountZKEmail is Account, SignerZKEmail, Initializable {
  function initialize(
      bytes32 accountSalt,
      IDKIMRegistry registry,
      IVerifier verifier,
      uint256 templateId
  ) public initializer {
      // Will revert if the signer is already initialized
      _setAccountSalt(accountSalt);
      _setDKIMRegistry(registry);
      _setVerifier(verifier);
      _setTemplateId(templateId);
  }
}
```

IMPORTANT: Avoiding to call {_setAccountSalt}, {_setDKIMRegistry}, {_setVerifier} and {_setTemplateId}
either during construction (if used standalone) or during initialization (if used as a clone) may
leave the signer either front-runnable or unusable.

[.contract-index]
.Functions
--
* `++accountSalt()++`
* `++DKIMRegistry()++`
* `++verifier()++`
* `++templateId()++`
* `++_setAccountSalt(accountSalt_)++`
* `++_setDKIMRegistry(registry_)++`
* `++_setVerifier(verifier_)++`
* `++_setTemplateId(templateId_)++`
* `++_rawSignatureValidation(hash, signature)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-index]
.Errors
--
* `++InvalidEmailProof(err)++`

[.contract-subindex-inherited]
.AbstractSigner

--

[.contract-item]
[[SignerZKEmail-accountSalt--]]
==== `[.contract-item-name]#++accountSalt++#++() → bytes32++` [.item-kind]#public#

Unique identifier for owner of this contract defined as a hash of an email address and an account code.

An account code is a random integer in a finite scalar field of https://neuromancer.sk/std/bn/bn254[BN254] curve.
It is a private randomness to derive a CREATE2 salt of the user's Ethereum address
from the email address, i.e., userEtherAddr := CREATE2(hash(userEmailAddr, accountCode)).

The account salt is used for:

* Privacy: Enables email address privacy on-chain so long as the randomly generated account code is not revealed
  to an adversary.
* Security: Provides a unique identifier that cannot be easily guessed or brute-forced, as it's derived
  from both the email address and a random account code.
* Deterministic Address Generation: Enables the creation of deterministic addresses based on email addresses,
  allowing users to recover their accounts using only their email.

[.contract-item]
[[SignerZKEmail-DKIMRegistry--]]
==== `[.contract-item-name]#++DKIMRegistry++#++() → contract IDKIMRegistry++` [.item-kind]#public#

An instance of the DKIM registry contract.
See https://docs.zk.email/architecture/dkim-verification[DKIM Verification].

[.contract-item]
[[SignerZKEmail-verifier--]]
==== `[.contract-item-name]#++verifier++#++() → contract IVerifier++` [.item-kind]#public#

An instance of the Verifier contract.
See https://docs.zk.email/architecture/zk-proofs#how-zk-email-uses-zero-knowledge-proofs[ZK Proofs].

[.contract-item]
[[SignerZKEmail-templateId--]]
==== `[.contract-item-name]#++templateId++#++() → uint256++` [.item-kind]#public#

The command template of the sign hash command.

[.contract-item]
[[SignerZKEmail-_setAccountSalt-bytes32-]]
==== `[.contract-item-name]#++_setAccountSalt++#++(bytes32 accountSalt_)++` [.item-kind]#internal#

Set the {accountSalt}.

[.contract-item]
[[SignerZKEmail-_setDKIMRegistry-contract-IDKIMRegistry-]]
==== `[.contract-item-name]#++_setDKIMRegistry++#++(contract IDKIMRegistry registry_)++` [.item-kind]#internal#

Set the {DKIMRegistry} contract address.

[.contract-item]
[[SignerZKEmail-_setVerifier-contract-IVerifier-]]
==== `[.contract-item-name]#++_setVerifier++#++(contract IVerifier verifier_)++` [.item-kind]#internal#

Set the {verifier} contract address.

[.contract-item]
[[SignerZKEmail-_setTemplateId-uint256-]]
==== `[.contract-item-name]#++_setTemplateId++#++(uint256 templateId_)++` [.item-kind]#internal#

Set the command's {templateId}.

[.contract-item]
[[SignerZKEmail-_rawSignatureValidation-bytes32-bytes-]]
==== `[.contract-item-name]#++_rawSignatureValidation++#++(bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

See {AbstractSigner-_rawSignatureValidation}. Validates a raw signature by:

1. Decoding the email authentication message from the signature
2. Verifying the hash matches the command parameters
3. Checking the template ID matches
4. Validating the account salt
5. Verifying the email proof

[.contract-item]
[[SignerZKEmail-InvalidEmailProof-enum-ZKEmailUtils-EmailProofError-]]
==== `[.contract-item-name]#++InvalidEmailProof++#++(enum ZKEmailUtils.EmailProofError err)++` [.item-kind]#error#

Proof verification error.

=== ERC-7913

:isValidSignatureNow: pass:normal[xref:#ERC7913Utils-isValidSignatureNow-bytes-bytes32-bytes-[`++isValidSignatureNow++`]]

[.contract]
[[ERC7913Utils]]
=== `++ERC7913Utils++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/ERC7913Utils.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/ERC7913Utils.sol";
```

Library that provides common ERC-7913 utility functions.

This library extends the functionality of
https://docs.openzeppelin.com/contracts/5.x/api/utils#SignatureChecker[SignatureChecker]
to support signature verification for keys that do not have an Ethereum address of their own
as with ERC-1271.

See https://eips.ethereum.org/EIPS/eip-7913[ERC-7913].

[.contract-index]
.Functions
--
* `++isValidSignatureNow(signer, hash, signature)++`

--

[.contract-item]
[[ERC7913Utils-isValidSignatureNow-bytes-bytes32-bytes-]]
==== `[.contract-item-name]#++isValidSignatureNow++#++(bytes signer, bytes32 hash, bytes signature) → bool++` [.item-kind]#internal#

Verifies a signature for a given signer and hash.

The signer is a `bytes` object that is the concatenation of an address and optionally a key:
`verifier || key`. A signer must be at least 20 bytes long.

Verification is done as follows:
- If `signer.length < 20`: verification fails
- If `signer.length == 20`: verification is done using {SignatureChecker}
- Otherwise: verification is done using {IERC7913SignatureVerifier}

:verify: pass:normal[xref:#ERC7913SignatureVerifierP256-verify-bytes-bytes32-bytes-[`++verify++`]]

[.contract]
[[ERC7913SignatureVerifierP256]]
=== `++ERC7913SignatureVerifierP256++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/ERC7913SignatureVerifierP256.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/ERC7913SignatureVerifierP256.sol";
```

ERC-7913 signature verifier that support P256 (secp256r1) keys.

[.contract-index]
.Functions
--
* `++verify(key, hash, signature)++`

[.contract-subindex-inherited]
.IERC7913SignatureVerifier

--

[.contract-item]
[[ERC7913SignatureVerifierP256-verify-bytes-bytes32-bytes-]]
==== `[.contract-item-name]#++verify++#++(bytes key, bytes32 hash, bytes signature) → bytes4++` [.item-kind]#public#

Verifies `signature` as a valid signature of `hash` by `key`.

MUST return the bytes4 magic value IERC7913SignatureVerifier.verify.selector if the signature is valid.
SHOULD return 0xffffffff or revert if the signature is not valid.
SHOULD return 0xffffffff or revert if the key is empty

:verify: pass:normal[xref:#ERC7913SignatureVerifierRSA-verify-bytes-bytes32-bytes-[`++verify++`]]

[.contract]
[[ERC7913SignatureVerifierRSA]]
=== `++ERC7913SignatureVerifierRSA++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/ERC7913SignatureVerifierRSA.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/cryptography/ERC7913SignatureVerifierRSA.sol";
```

ERC-7913 signature verifier that support RSA keys.

[.contract-index]
.Functions
--
* `++verify(key, hash, signature)++`

[.contract-subindex-inherited]
.IERC7913SignatureVerifier

--

[.contract-item]
[[ERC7913SignatureVerifierRSA-verify-bytes-bytes32-bytes-]]
==== `[.contract-item-name]#++verify++#++(bytes key, bytes32 hash, bytes signature) → bytes4++` [.item-kind]#public#

Verifies `signature` as a valid signature of `hash` by `key`.

MUST return the bytes4 magic value IERC7913SignatureVerifier.verify.selector if the signature is valid.
SHOULD return 0xffffffff or revert if the signature is not valid.
SHOULD return 0xffffffff or revert if the key is empty

== Structs

:StringSet: pass:normal[xref:#EnumerableSetExtended-StringSet[`++StringSet++`]]
:add: pass:normal[xref:#EnumerableSetExtended-add-struct-EnumerableSetExtended-StringSet-string-[`++add++`]]
:remove: pass:normal[xref:#EnumerableSetExtended-remove-struct-EnumerableSetExtended-StringSet-string-[`++remove++`]]
:clear: pass:normal[xref:#EnumerableSetExtended-clear-struct-EnumerableSetExtended-StringSet-[`++clear++`]]
:contains: pass:normal[xref:#EnumerableSetExtended-contains-struct-EnumerableSetExtended-StringSet-string-[`++contains++`]]
:length: pass:normal[xref:#EnumerableSetExtended-length-struct-EnumerableSetExtended-StringSet-[`++length++`]]
:at: pass:normal[xref:#EnumerableSetExtended-at-struct-EnumerableSetExtended-StringSet-uint256-[`++at++`]]
:values: pass:normal[xref:#EnumerableSetExtended-values-struct-EnumerableSetExtended-StringSet-[`++values++`]]
:BytesSet: pass:normal[xref:#EnumerableSetExtended-BytesSet[`++BytesSet++`]]
:add: pass:normal[xref:#EnumerableSetExtended-add-struct-EnumerableSetExtended-BytesSet-bytes-[`++add++`]]
:remove: pass:normal[xref:#EnumerableSetExtended-remove-struct-EnumerableSetExtended-BytesSet-bytes-[`++remove++`]]
:clear: pass:normal[xref:#EnumerableSetExtended-clear-struct-EnumerableSetExtended-BytesSet-[`++clear++`]]
:contains: pass:normal[xref:#EnumerableSetExtended-contains-struct-EnumerableSetExtended-BytesSet-bytes-[`++contains++`]]
:length: pass:normal[xref:#EnumerableSetExtended-length-struct-EnumerableSetExtended-BytesSet-[`++length++`]]
:at: pass:normal[xref:#EnumerableSetExtended-at-struct-EnumerableSetExtended-BytesSet-uint256-[`++at++`]]
:values: pass:normal[xref:#EnumerableSetExtended-values-struct-EnumerableSetExtended-BytesSet-[`++values++`]]
:Bytes32x2Set: pass:normal[xref:#EnumerableSetExtended-Bytes32x2Set[`++Bytes32x2Set++`]]
:add: pass:normal[xref:#EnumerableSetExtended-add-struct-EnumerableSetExtended-Bytes32x2Set-bytes32-2--[`++add++`]]
:remove: pass:normal[xref:#EnumerableSetExtended-remove-struct-EnumerableSetExtended-Bytes32x2Set-bytes32-2--[`++remove++`]]
:clear: pass:normal[xref:#EnumerableSetExtended-clear-struct-EnumerableSetExtended-Bytes32x2Set-[`++clear++`]]
:contains: pass:normal[xref:#EnumerableSetExtended-contains-struct-EnumerableSetExtended-Bytes32x2Set-bytes32-2--[`++contains++`]]
:length: pass:normal[xref:#EnumerableSetExtended-length-struct-EnumerableSetExtended-Bytes32x2Set-[`++length++`]]
:at: pass:normal[xref:#EnumerableSetExtended-at-struct-EnumerableSetExtended-Bytes32x2Set-uint256-[`++at++`]]
:values: pass:normal[xref:#EnumerableSetExtended-values-struct-EnumerableSetExtended-Bytes32x2Set-[`++values++`]]

[.contract]
[[EnumerableSetExtended]]
=== `++EnumerableSetExtended++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/structs/EnumerableSetExtended.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/structs/EnumerableSetExtended.sol";
```

Library for managing
https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of non-value
types.

Sets have the following properties:

- Elements are added, removed, and checked for existence in constant time
(O(1)).
- Elements are enumerated in O(n). No guarantees are made on the ordering.
- Set can be cleared (all elements removed) in O(n).

```solidity
contract Example {
    // Add the library methods
    using EnumerableSetExtended for EnumerableSetExtended.StringSet;

    // Declare a set state variable
    EnumerableSetExtended.StringSet private mySet;
}
```

Sets of type `string` (`StringSet`), `bytes` (`BytesSet`) and
`bytes32[2]` (`Bytes32x2Set`) are supported.

[WARNING]
====
Trying to delete such a structure from storage will likely result in data corruption, rendering the structure
unusable.
See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.

In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an
array of EnumerableSet.
====

NOTE: This is an extension of openzeppelin/contracts/utils/struct/EnumerableSet.sol.

[.contract-index]
.Functions
--
* `++add(self, value)++`
* `++remove(self, value)++`
* `++clear(set)++`
* `++contains(self, value)++`
* `++length(self)++`
* `++at(self, index)++`
* `++values(self)++`
* `++add(self, value)++`
* `++remove(self, value)++`
* `++clear(set)++`
* `++contains(self, value)++`
* `++length(self)++`
* `++at(self, index)++`
* `++values(self)++`
* `++add(self, value)++`
* `++remove(self, value)++`
* `++clear(self)++`
* `++contains(self, value)++`
* `++length(self)++`
* `++at(self, index)++`
* `++values(self)++`

--

[.contract-item]
[[EnumerableSetExtended-add-struct-EnumerableSetExtended-StringSet-string-]]
==== `[.contract-item-name]#++add++#++(struct EnumerableSetExtended.StringSet self, string value) → bool++` [.item-kind]#internal#

Add a value to a set. O(1).

Returns true if the value was added to the set, that is if it was not
already present.

[.contract-item]
[[EnumerableSetExtended-remove-struct-EnumerableSetExtended-StringSet-string-]]
==== `[.contract-item-name]#++remove++#++(struct EnumerableSetExtended.StringSet self, string value) → bool++` [.item-kind]#internal#

Removes a value from a set. O(1).

Returns true if the value was removed from the set, that is if it was
present.

[.contract-item]
[[EnumerableSetExtended-clear-struct-EnumerableSetExtended-StringSet-]]
==== `[.contract-item-name]#++clear++#++(struct EnumerableSetExtended.StringSet set)++` [.item-kind]#internal#

Removes all the values from a set. O(n).

WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the
function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.

[.contract-item]
[[EnumerableSetExtended-contains-struct-EnumerableSetExtended-StringSet-string-]]
==== `[.contract-item-name]#++contains++#++(struct EnumerableSetExtended.StringSet self, string value) → bool++` [.item-kind]#internal#

Returns true if the value is in the set. O(1).

[.contract-item]
[[EnumerableSetExtended-length-struct-EnumerableSetExtended-StringSet-]]
==== `[.contract-item-name]#++length++#++(struct EnumerableSetExtended.StringSet self) → uint256++` [.item-kind]#internal#

Returns the number of values on the set. O(1).

[.contract-item]
[[EnumerableSetExtended-at-struct-EnumerableSetExtended-StringSet-uint256-]]
==== `[.contract-item-name]#++at++#++(struct EnumerableSetExtended.StringSet self, uint256 index) → string++` [.item-kind]#internal#

Returns the value stored at position `index` in the set. O(1).

Note that there are no guarantees on the ordering of values inside the
array, and it may change when more values are added or removed.

Requirements:

- `index` must be strictly less than {length}.

[.contract-item]
[[EnumerableSetExtended-values-struct-EnumerableSetExtended-StringSet-]]
==== `[.contract-item-name]#++values++#++(struct EnumerableSetExtended.StringSet self) → string[]++` [.item-kind]#internal#

Return the entire set in an array

WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
this function has an unbounded cost, and using it as part of a state-changing function may render the function
uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.

[.contract-item]
[[EnumerableSetExtended-add-struct-EnumerableSetExtended-BytesSet-bytes-]]
==== `[.contract-item-name]#++add++#++(struct EnumerableSetExtended.BytesSet self, bytes value) → bool++` [.item-kind]#internal#

Add a value to a set. O(1).

Returns true if the value was added to the set, that is if it was not
already present.

[.contract-item]
[[EnumerableSetExtended-remove-struct-EnumerableSetExtended-BytesSet-bytes-]]
==== `[.contract-item-name]#++remove++#++(struct EnumerableSetExtended.BytesSet self, bytes value) → bool++` [.item-kind]#internal#

Removes a value from a set. O(1).

Returns true if the value was removed from the set, that is if it was
present.

[.contract-item]
[[EnumerableSetExtended-clear-struct-EnumerableSetExtended-BytesSet-]]
==== `[.contract-item-name]#++clear++#++(struct EnumerableSetExtended.BytesSet set)++` [.item-kind]#internal#

Removes all the values from a set. O(n).

WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the
function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.

[.contract-item]
[[EnumerableSetExtended-contains-struct-EnumerableSetExtended-BytesSet-bytes-]]
==== `[.contract-item-name]#++contains++#++(struct EnumerableSetExtended.BytesSet self, bytes value) → bool++` [.item-kind]#internal#

Returns true if the value is in the set. O(1).

[.contract-item]
[[EnumerableSetExtended-length-struct-EnumerableSetExtended-BytesSet-]]
==== `[.contract-item-name]#++length++#++(struct EnumerableSetExtended.BytesSet self) → uint256++` [.item-kind]#internal#

Returns the number of values on the set. O(1).

[.contract-item]
[[EnumerableSetExtended-at-struct-EnumerableSetExtended-BytesSet-uint256-]]
==== `[.contract-item-name]#++at++#++(struct EnumerableSetExtended.BytesSet self, uint256 index) → bytes++` [.item-kind]#internal#

Returns the value stored at position `index` in the set. O(1).

Note that there are no guarantees on the ordering of values inside the
array, and it may change when more values are added or removed.

Requirements:

- `index` must be strictly less than {length}.

[.contract-item]
[[EnumerableSetExtended-values-struct-EnumerableSetExtended-BytesSet-]]
==== `[.contract-item-name]#++values++#++(struct EnumerableSetExtended.BytesSet self) → bytes[]++` [.item-kind]#internal#

Return the entire set in an array

WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
this function has an unbounded cost, and using it as part of a state-changing function may render the function
uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.

[.contract-item]
[[EnumerableSetExtended-add-struct-EnumerableSetExtended-Bytes32x2Set-bytes32-2--]]
==== `[.contract-item-name]#++add++#++(struct EnumerableSetExtended.Bytes32x2Set self, bytes32[2] value) → bool++` [.item-kind]#internal#

Add a value to a set. O(1).

Returns true if the value was added to the set, that is if it was not
already present.

[.contract-item]
[[EnumerableSetExtended-remove-struct-EnumerableSetExtended-Bytes32x2Set-bytes32-2--]]
==== `[.contract-item-name]#++remove++#++(struct EnumerableSetExtended.Bytes32x2Set self, bytes32[2] value) → bool++` [.item-kind]#internal#

Removes a value from a set. O(1).

Returns true if the value was removed from the set, that is if it was
present.

[.contract-item]
[[EnumerableSetExtended-clear-struct-EnumerableSetExtended-Bytes32x2Set-]]
==== `[.contract-item-name]#++clear++#++(struct EnumerableSetExtended.Bytes32x2Set self)++` [.item-kind]#internal#

Removes all the values from a set. O(n).

WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the
function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.

[.contract-item]
[[EnumerableSetExtended-contains-struct-EnumerableSetExtended-Bytes32x2Set-bytes32-2--]]
==== `[.contract-item-name]#++contains++#++(struct EnumerableSetExtended.Bytes32x2Set self, bytes32[2] value) → bool++` [.item-kind]#internal#

Returns true if the value is in the set. O(1).

[.contract-item]
[[EnumerableSetExtended-length-struct-EnumerableSetExtended-Bytes32x2Set-]]
==== `[.contract-item-name]#++length++#++(struct EnumerableSetExtended.Bytes32x2Set self) → uint256++` [.item-kind]#internal#

Returns the number of values on the set. O(1).

[.contract-item]
[[EnumerableSetExtended-at-struct-EnumerableSetExtended-Bytes32x2Set-uint256-]]
==== `[.contract-item-name]#++at++#++(struct EnumerableSetExtended.Bytes32x2Set self, uint256 index) → bytes32[2]++` [.item-kind]#internal#

Returns the value stored at position `index` in the set. O(1).

Note that there are no guarantees on the ordering of values inside the
array, and it may change when more values are added or removed.

Requirements:

- `index` must be strictly less than {length}.

[.contract-item]
[[EnumerableSetExtended-values-struct-EnumerableSetExtended-Bytes32x2Set-]]
==== `[.contract-item-name]#++values++#++(struct EnumerableSetExtended.Bytes32x2Set self) → bytes32[2][]++` [.item-kind]#internal#

Return the entire set in an array

WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
this function has an unbounded cost, and using it as part of a state-changing function may render the function
uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.

:EnumerableMapNonexistentBytesKey: pass:normal[xref:#EnumerableMapExtended-EnumerableMapNonexistentBytesKey-bytes-[`++EnumerableMapNonexistentBytesKey++`]]
:BytesToUintMap: pass:normal[xref:#EnumerableMapExtended-BytesToUintMap[`++BytesToUintMap++`]]
:set: pass:normal[xref:#EnumerableMapExtended-set-struct-EnumerableMapExtended-BytesToUintMap-bytes-uint256-[`++set++`]]
:remove: pass:normal[xref:#EnumerableMapExtended-remove-struct-EnumerableMapExtended-BytesToUintMap-bytes-[`++remove++`]]
:clear: pass:normal[xref:#EnumerableMapExtended-clear-struct-EnumerableMapExtended-BytesToUintMap-[`++clear++`]]
:contains: pass:normal[xref:#EnumerableMapExtended-contains-struct-EnumerableMapExtended-BytesToUintMap-bytes-[`++contains++`]]
:length: pass:normal[xref:#EnumerableMapExtended-length-struct-EnumerableMapExtended-BytesToUintMap-[`++length++`]]
:at: pass:normal[xref:#EnumerableMapExtended-at-struct-EnumerableMapExtended-BytesToUintMap-uint256-[`++at++`]]
:tryGet: pass:normal[xref:#EnumerableMapExtended-tryGet-struct-EnumerableMapExtended-BytesToUintMap-bytes-[`++tryGet++`]]
:get: pass:normal[xref:#EnumerableMapExtended-get-struct-EnumerableMapExtended-BytesToUintMap-bytes-[`++get++`]]
:keys: pass:normal[xref:#EnumerableMapExtended-keys-struct-EnumerableMapExtended-BytesToUintMap-[`++keys++`]]
:EnumerableMapNonexistentStringKey: pass:normal[xref:#EnumerableMapExtended-EnumerableMapNonexistentStringKey-string-[`++EnumerableMapNonexistentStringKey++`]]
:StringToStringMap: pass:normal[xref:#EnumerableMapExtended-StringToStringMap[`++StringToStringMap++`]]
:set: pass:normal[xref:#EnumerableMapExtended-set-struct-EnumerableMapExtended-StringToStringMap-string-string-[`++set++`]]
:remove: pass:normal[xref:#EnumerableMapExtended-remove-struct-EnumerableMapExtended-StringToStringMap-string-[`++remove++`]]
:clear: pass:normal[xref:#EnumerableMapExtended-clear-struct-EnumerableMapExtended-StringToStringMap-[`++clear++`]]
:contains: pass:normal[xref:#EnumerableMapExtended-contains-struct-EnumerableMapExtended-StringToStringMap-string-[`++contains++`]]
:length: pass:normal[xref:#EnumerableMapExtended-length-struct-EnumerableMapExtended-StringToStringMap-[`++length++`]]
:at: pass:normal[xref:#EnumerableMapExtended-at-struct-EnumerableMapExtended-StringToStringMap-uint256-[`++at++`]]
:tryGet: pass:normal[xref:#EnumerableMapExtended-tryGet-struct-EnumerableMapExtended-StringToStringMap-string-[`++tryGet++`]]
:get: pass:normal[xref:#EnumerableMapExtended-get-struct-EnumerableMapExtended-StringToStringMap-string-[`++get++`]]
:keys: pass:normal[xref:#EnumerableMapExtended-keys-struct-EnumerableMapExtended-StringToStringMap-[`++keys++`]]

[.contract]
[[EnumerableMapExtended]]
=== `++EnumerableMapExtended++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/structs/EnumerableMapExtended.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/structs/EnumerableMapExtended.sol";
```

Library for managing an enumerable variant of Solidity's
https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]
type for non-value types as keys.

Maps have the following properties:

- Entries are added, removed, and checked for existence in constant time
(O(1)).
- Entries are enumerated in O(n). No guarantees are made on the ordering.
- Map can be cleared (all entries removed) in O(n).

```solidity
contract Example {
    // Add the library methods
    using EnumerableMapExtended for EnumerableMapExtended.BytesToUintMap;

    // Declare a set state variable
    EnumerableMapExtended.BytesToUintMap private myMap;
}
```

The following map types are supported:

- `bytes -> uint256` (`BytesToUintMap`)
- `string -> string` (`StringToStringMap`)

[WARNING]
====
Trying to delete such a structure from storage will likely result in data corruption, rendering the structure
unusable.
See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.

In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an
array of EnumerableMap.
====

NOTE: Extensions of openzeppelin/contracts/utils/struct/EnumerableMap.sol.

[.contract-index]
.Functions
--
* `++set(map, key, value)++`
* `++remove(map, key)++`
* `++clear(map)++`
* `++contains(map, key)++`
* `++length(map)++`
* `++at(map, index)++`
* `++tryGet(map, key)++`
* `++get(map, key)++`
* `++keys(map)++`
* `++set(map, key, value)++`
* `++remove(map, key)++`
* `++clear(map)++`
* `++contains(map, key)++`
* `++length(map)++`
* `++at(map, index)++`
* `++tryGet(map, key)++`
* `++get(map, key)++`
* `++keys(map)++`

--

[.contract-index]
.Errors
--
* `++EnumerableMapNonexistentBytesKey(key)++`
* `++EnumerableMapNonexistentStringKey(key)++`

--

[.contract-item]
[[EnumerableMapExtended-set-struct-EnumerableMapExtended-BytesToUintMap-bytes-uint256-]]
==== `[.contract-item-name]#++set++#++(struct EnumerableMapExtended.BytesToUintMap map, bytes key, uint256 value) → bool++` [.item-kind]#internal#

Adds a key-value pair to a map, or updates the value for an existing
key. O(1).

Returns true if the key was added to the map, that is if it was not
already present.

[.contract-item]
[[EnumerableMapExtended-remove-struct-EnumerableMapExtended-BytesToUintMap-bytes-]]
==== `[.contract-item-name]#++remove++#++(struct EnumerableMapExtended.BytesToUintMap map, bytes key) → bool++` [.item-kind]#internal#

Removes a key-value pair from a map. O(1).

Returns true if the key was removed from the map, that is if it was present.

[.contract-item]
[[EnumerableMapExtended-clear-struct-EnumerableMapExtended-BytesToUintMap-]]
==== `[.contract-item-name]#++clear++#++(struct EnumerableMapExtended.BytesToUintMap map)++` [.item-kind]#internal#

Removes all the entries from a map. O(n).

WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the
function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.

[.contract-item]
[[EnumerableMapExtended-contains-struct-EnumerableMapExtended-BytesToUintMap-bytes-]]
==== `[.contract-item-name]#++contains++#++(struct EnumerableMapExtended.BytesToUintMap map, bytes key) → bool++` [.item-kind]#internal#

Returns true if the key is in the map. O(1).

[.contract-item]
[[EnumerableMapExtended-length-struct-EnumerableMapExtended-BytesToUintMap-]]
==== `[.contract-item-name]#++length++#++(struct EnumerableMapExtended.BytesToUintMap map) → uint256++` [.item-kind]#internal#

Returns the number of key-value pairs in the map. O(1).

[.contract-item]
[[EnumerableMapExtended-at-struct-EnumerableMapExtended-BytesToUintMap-uint256-]]
==== `[.contract-item-name]#++at++#++(struct EnumerableMapExtended.BytesToUintMap map, uint256 index) → bytes key, uint256 value++` [.item-kind]#internal#

Returns the key-value pair stored at position `index` in the map. O(1).

Note that there are no guarantees on the ordering of entries inside the
array, and it may change when more entries are added or removed.

Requirements:

- `index` must be strictly less than {length}.

[.contract-item]
[[EnumerableMapExtended-tryGet-struct-EnumerableMapExtended-BytesToUintMap-bytes-]]
==== `[.contract-item-name]#++tryGet++#++(struct EnumerableMapExtended.BytesToUintMap map, bytes key) → bool exists, uint256 value++` [.item-kind]#internal#

Tries to returns the value associated with `key`. O(1).
Does not revert if `key` is not in the map.

[.contract-item]
[[EnumerableMapExtended-get-struct-EnumerableMapExtended-BytesToUintMap-bytes-]]
==== `[.contract-item-name]#++get++#++(struct EnumerableMapExtended.BytesToUintMap map, bytes key) → uint256 value++` [.item-kind]#internal#

Returns the value associated with `key`. O(1).

Requirements:

- `key` must be in the map.

[.contract-item]
[[EnumerableMapExtended-keys-struct-EnumerableMapExtended-BytesToUintMap-]]
==== `[.contract-item-name]#++keys++#++(struct EnumerableMapExtended.BytesToUintMap map) → bytes[]++` [.item-kind]#internal#

Return the an array containing all the keys

WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
this function has an unbounded cost, and using it as part of a state-changing function may render the function
uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.

[.contract-item]
[[EnumerableMapExtended-set-struct-EnumerableMapExtended-StringToStringMap-string-string-]]
==== `[.contract-item-name]#++set++#++(struct EnumerableMapExtended.StringToStringMap map, string key, string value) → bool++` [.item-kind]#internal#

Adds a key-value pair to a map, or updates the value for an existing
key. O(1).

Returns true if the key was added to the map, that is if it was not
already present.

[.contract-item]
[[EnumerableMapExtended-remove-struct-EnumerableMapExtended-StringToStringMap-string-]]
==== `[.contract-item-name]#++remove++#++(struct EnumerableMapExtended.StringToStringMap map, string key) → bool++` [.item-kind]#internal#

Removes a key-value pair from a map. O(1).

Returns true if the key was removed from the map, that is if it was present.

[.contract-item]
[[EnumerableMapExtended-clear-struct-EnumerableMapExtended-StringToStringMap-]]
==== `[.contract-item-name]#++clear++#++(struct EnumerableMapExtended.StringToStringMap map)++` [.item-kind]#internal#

Removes all the entries from a map. O(n).

WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the
function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.

[.contract-item]
[[EnumerableMapExtended-contains-struct-EnumerableMapExtended-StringToStringMap-string-]]
==== `[.contract-item-name]#++contains++#++(struct EnumerableMapExtended.StringToStringMap map, string key) → bool++` [.item-kind]#internal#

Returns true if the key is in the map. O(1).

[.contract-item]
[[EnumerableMapExtended-length-struct-EnumerableMapExtended-StringToStringMap-]]
==== `[.contract-item-name]#++length++#++(struct EnumerableMapExtended.StringToStringMap map) → uint256++` [.item-kind]#internal#

Returns the number of key-value pairs in the map. O(1).

[.contract-item]
[[EnumerableMapExtended-at-struct-EnumerableMapExtended-StringToStringMap-uint256-]]
==== `[.contract-item-name]#++at++#++(struct EnumerableMapExtended.StringToStringMap map, uint256 index) → string key, string value++` [.item-kind]#internal#

Returns the key-value pair stored at position `index` in the map. O(1).

Note that there are no guarantees on the ordering of entries inside the
array, and it may change when more entries are added or removed.

Requirements:

- `index` must be strictly less than {length}.

[.contract-item]
[[EnumerableMapExtended-tryGet-struct-EnumerableMapExtended-StringToStringMap-string-]]
==== `[.contract-item-name]#++tryGet++#++(struct EnumerableMapExtended.StringToStringMap map, string key) → bool exists, string value++` [.item-kind]#internal#

Tries to returns the value associated with `key`. O(1).
Does not revert if `key` is not in the map.

[.contract-item]
[[EnumerableMapExtended-get-struct-EnumerableMapExtended-StringToStringMap-string-]]
==== `[.contract-item-name]#++get++#++(struct EnumerableMapExtended.StringToStringMap map, string key) → string value++` [.item-kind]#internal#

Returns the value associated with `key`. O(1).

Requirements:

- `key` must be in the map.

[.contract-item]
[[EnumerableMapExtended-keys-struct-EnumerableMapExtended-StringToStringMap-]]
==== `[.contract-item-name]#++keys++#++(struct EnumerableMapExtended.StringToStringMap map) → string[]++` [.item-kind]#internal#

Return the an array containing all the keys

WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
this function has an unbounded cost, and using it as part of a state-changing function may render the function
uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.

[.contract-item]
[[EnumerableMapExtended-EnumerableMapNonexistentBytesKey-bytes-]]
==== `[.contract-item-name]#++EnumerableMapNonexistentBytesKey++#++(bytes key)++` [.item-kind]#error#

Query for a nonexistent map key.

[.contract-item]
[[EnumerableMapExtended-EnumerableMapNonexistentStringKey-string-]]
==== `[.contract-item-name]#++EnumerableMapNonexistentStringKey++#++(string key)++` [.item-kind]#error#

Query for a nonexistent map key.

== Libraries

:Mask: pass:normal[xref:#Masks-Mask[`++Mask++`]]
:toMask: pass:normal[xref:#Masks-toMask-uint8-[`++toMask++`]]
:toMask: pass:normal[xref:#Masks-toMask-uint8---[`++toMask++`]]
:get: pass:normal[xref:#Masks-get-Masks-Mask-uint8-[`++get++`]]
:isEmpty: pass:normal[xref:#Masks-isEmpty-Masks-Mask-[`++isEmpty++`]]
:complement: pass:normal[xref:#Masks-complement-Masks-Mask-[`++complement++`]]
:union: pass:normal[xref:#Masks-union-Masks-Mask-Masks-Mask-[`++union++`]]
:intersection: pass:normal[xref:#Masks-intersection-Masks-Mask-Masks-Mask-[`++intersection++`]]
:difference: pass:normal[xref:#Masks-difference-Masks-Mask-Masks-Mask-[`++difference++`]]
:symmetricDifference: pass:normal[xref:#Masks-symmetricDifference-Masks-Mask-Masks-Mask-[`++symmetricDifference++`]]

[.contract]
[[Masks]]
=== `++Masks++` link:https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/Masks.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/community-contracts/utils/Masks.sol";
```

Library for handling bit masks

[.contract-index]
.Functions
--
* `++toMask(group)++`
* `++toMask(groups)++`
* `++get(self, group)++`
* `++isEmpty(self)++`
* `++complement(m1)++`
* `++union(m1, m2)++`
* `++intersection(m1, m2)++`
* `++difference(m1, m2)++`
* `++symmetricDifference(m1, m2)++`

--

[.contract-item]
[[Masks-toMask-uint8-]]
==== `[.contract-item-name]#++toMask++#++(uint8 group) → Masks.Mask++` [.item-kind]#internal#

Returns a new mask with the bit at `group` index set to 1.

[.contract-item]
[[Masks-toMask-uint8---]]
==== `[.contract-item-name]#++toMask++#++(uint8[] groups) → Masks.Mask++` [.item-kind]#internal#

Returns a new mask with the bits at `groups` indices set to 1.

[.contract-item]
[[Masks-get-Masks-Mask-uint8-]]
==== `[.contract-item-name]#++get++#++(Masks.Mask self, uint8 group) → bool++` [.item-kind]#internal#

Get value of the mask at `group` index

[.contract-item]
[[Masks-isEmpty-Masks-Mask-]]
==== `[.contract-item-name]#++isEmpty++#++(Masks.Mask self) → bool++` [.item-kind]#internal#

Whether the mask is `bytes32(0)`

[.contract-item]
[[Masks-complement-Masks-Mask-]]
==== `[.contract-item-name]#++complement++#++(Masks.Mask m1) → Masks.Mask++` [.item-kind]#internal#

Invert the bits of a mask

[.contract-item]
[[Masks-union-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++union++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Perform a bitwise OR operation on two masks

[.contract-item]
[[Masks-intersection-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++intersection++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Perform a bitwise AND operation on two masks

[.contract-item]
[[Masks-difference-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++difference++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Perform a bitwise difference operation on two masks (m1 - m2)

[.contract-item]
[[Masks-symmetricDifference-Masks-Mask-Masks-Mask-]]
==== `[.contract-item-name]#++symmetricDifference++#++(Masks.Mask m1, Masks.Mask m2) → Masks.Mask++` [.item-kind]#internal#

Returns the symmetric difference (∆) of two masks, also known as disjunctive union or exclusive OR (XOR)

