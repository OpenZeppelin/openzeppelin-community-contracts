= Utilities

Multiple libraries and general purpose utilities included in the community version of OpenZeppelin Contracts. These are only a set of utility contracts. For the full list, check out the xref:api:utils.adoc[API Reference].

== Cryptography

=== Validating Typed Data Signatures

_For prior knowledge on how to validate signatures on-chain, check out the https://docs.openzeppelin.com/contracts/5.x/utilities#checking_signatures_on_chain[OpenZeppelin Contracts documentation]_

As opposed to validating plain-text messages, it is possible to let your users sign structured data (i.e. typed values) in a way that is still readable on their wallets. This is possible by implementing https://docs.openzeppelin.com/contracts/api/utils#EIP712[`EIP712`], a standard way to encode structured data into a typed data hash.

To start validating signed typed structures, just validate the https://docs.openzeppelin.com/contracts/api/utils#EIP712-_hashTypedDataV4-bytes32-[typed data hash]:

[source,solidity]
----
include::api:example$utils/cryptography/MyContractDomain.sol[]
----

As part of the message, EIP-712 requires implementers to include a domain separator, which is a hash that includes the current smart contract address and the chain id where it's deployed. This way, the smart contract can be sure that the structured message was signed for its specific domain, avoiding replayability of signatures in smart contracts.

==== Validating Nested EIP-712 Signatures

Accounts (i.e. Smart Contract Wallets or Smart Accounts) are particularly likely to be controlled by multiple signers. As such, it's important to make sure that signatures are:

1. Only valid for the intended domain and account.
2. Validated in a way that's readable for the end signer.

On one hand, making sure that the Account signature is only valid for an specific smart contract (i.e. an application) is difficult since it requires to validate a signature whose domain is the application but also the Account itself. For these reason, the community developed https://eips.ethereum.org/EIPS/eip-7739[ERC-7739]; a defensive rehashing mechanism that binds a signature to a single domain using a nested EIP-712 approach (i.e. an EIP-712 typed structure wrapping another).

In case your smart contract validates signatures, using xref:api:utils/cryptography.adoc#ERC7739Signer[`ERC7739Signer`] will implement the https://docs.openzeppelin.com/contracts/api/interfaces#IERC1271[`IERC1271`] interface for validating smart contract signatures following the approach suggested by ERC-7739:

[source,solidity]
----
include::api:example$utils/cryptography/ERC7739SignerECDSA.sol[]
----

=== ERC-7913 Signature Verifiers

ERC-7913 extends the concept of signature verification to support keys that don't have their own Ethereum address. This is particularly useful for integrating non-Ethereum cryptographic curves, hardware devices, or other identity systems into smart accounts.

The standard defines a verifier interface that can be implemented to support different types of keys. A signer is represented as a `bytes` object that concatenates a verifier address and a key: `verifier || key`.

xref:api:utils/cryptography.adoc#ERC7913Utils[`ERC7913Utils`] provides functions for verifying signatures using ERC-7913 compatible verifiers:

[source,solidity]
----
using ERC7913Utils for bytes;

function _verify(bytes memory signer, bytes32 hash, bytes memory signature) internal view returns (bool) {
    return signer.isValidSignatureNow(hash, signature);
}
----

The verification process works as follows:

* If `signer.length < 20`: verification fails
* If `signer.length == 20`: verification is done using https://docs.openzeppelin.com/contracts/5.x/api/utils#SignatureChecker[SignatureChecker]
* Otherwise: verification is done using an ERC-7913 verifier.

This allows for backward compatibility with EOAs and ERC-1271 contracts while supporting new types of keys.

=== UTXOs (Unspent Transaction Outputs)

_For background on UTXO concepts, see the https://en.bitcoin.it/wiki/UTXO[Bitcoin UTXO model]_

UTXOs represent discrete units of value that can be spent exactly once, providing transaction graph privacy by breaking linkability between transfers. The xref:api:utils.adoc#UTXOs[`UTXOs`] library offers a minimal, flexible foundation for implementing UTXO-like systems in Ethereum smart contracts.

==== Basic UTXO Operations

The library uses `bytes32` for values to support multiple representations: plaintext amounts, encrypted values (FHE), zero-knowledge commitments, or other privacy-preserving formats:

[source,solidity]
----
import {UTXOs} from "@openzeppelin/contracts/utils/UTXOs.sol";

contract BasicUTXOToken {
    using UTXOs for UTXOs.Note;
    
    mapping(bytes32 => UTXOs.Note) private _notes;
    mapping(address => bytes32[]) private _ownerToNotes;  // Separate indexing
    
    function mint(address to, uint256 amount) external {
        bytes32 noteId = keccak256(abi.encode(block.timestamp, to, amount));
        bytes32 value = bytes32(amount);  // Convert uint256 to bytes32
        
        _notes[noteId].create(to, value);
        _ownerToNotes[to].push(noteId);
    }
    
    function transfer(bytes32 fromNoteId, address to, uint256 amount) external {
        UTXOs.Note storage fromNote = _notes[fromNoteId];
        require(fromNote.owner == msg.sender, "Not owner");
        
        uint256 currentValue = uint256(fromNote.value);
        require(currentValue >= amount, "Insufficient value");
        
        // Remove spent note
        _removeFromIndex(msg.sender, fromNoteId);
        fromNote.remove();
        
        // Create new notes
        bytes32 toNoteId = keccak256(abi.encode(block.timestamp, to, "recipient"));
        _notes[toNoteId].create(to, bytes32(amount));
        _ownerToNotes[to].push(toNoteId);
        
        // Create change note if needed
        if (currentValue > amount) {
            bytes32 changeNoteId = keccak256(abi.encode(block.timestamp, msg.sender, "change"));
            _notes[changeNoteId].create(msg.sender, bytes32(currentValue - amount));
            _ownerToNotes[msg.sender].push(changeNoteId);
        }
    }
}
----

==== Use Cases

* **Privacy Tokens**: Combine with FHE for maximum privacy (encrypted amounts + untraceable transaction graphs)
* **Mixer Protocols**: Break transaction links while maintaining verifiable balances  
* **Layer-2 Solutions**: Efficient fraud proofs and state transitions
* **DeFi Privacy**: Anonymous lending, trading, and yield farming
* **Cross-Chain Bridges**: Interoperability with UTXO-based blockchains like Bitcoin

The `bytes32` value design makes UTXOs a universal primitive for any privacy-preserving system on Ethereum.
